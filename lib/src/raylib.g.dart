// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint, unused_import
import 'dart:ffi' as ffi;

@ffi.Native<ffi.Void Function(ffi.Int, ffi.Int, ffi.Pointer<ffi.Char>)>()
external void InitWindow(int width, int height, ffi.Pointer<ffi.Char> title);

@ffi.Native<ffi.Void Function()>()
external void CloseWindow();

@ffi.Native<ffi.Bool Function()>()
external bool WindowShouldClose();

@ffi.Native<ffi.Bool Function()>()
external bool IsWindowReady();

@ffi.Native<ffi.Bool Function()>()
external bool IsWindowFullscreen();

@ffi.Native<ffi.Bool Function()>()
external bool IsWindowHidden();

@ffi.Native<ffi.Bool Function()>()
external bool IsWindowMinimized();

@ffi.Native<ffi.Bool Function()>()
external bool IsWindowMaximized();

@ffi.Native<ffi.Bool Function()>()
external bool IsWindowFocused();

@ffi.Native<ffi.Bool Function()>()
external bool IsWindowResized();

@ffi.Native<ffi.Bool Function(ffi.UnsignedInt)>()
external bool IsWindowState(int flag);

@ffi.Native<ffi.Void Function(ffi.UnsignedInt)>()
external void SetWindowState(int flags);

@ffi.Native<ffi.Void Function(ffi.UnsignedInt)>()
external void ClearWindowState(int flags);

@ffi.Native<ffi.Void Function()>()
external void ToggleFullscreen();

@ffi.Native<ffi.Void Function()>()
external void ToggleBorderlessWindowed();

@ffi.Native<ffi.Void Function()>()
external void MaximizeWindow();

@ffi.Native<ffi.Void Function()>()
external void MinimizeWindow();

@ffi.Native<ffi.Void Function()>()
external void RestoreWindow();

@ffi.Native<ffi.Void Function(Image)>()
external void SetWindowIcon(Image image);

@ffi.Native<ffi.Void Function(ffi.Pointer<Image>, ffi.Int)>()
external void SetWindowIcons(ffi.Pointer<Image> images, int count);

@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Char>)>()
external void SetWindowTitle(ffi.Pointer<ffi.Char> title);

@ffi.Native<ffi.Void Function(ffi.Int, ffi.Int)>()
external void SetWindowPosition(int x, int y);

@ffi.Native<ffi.Void Function(ffi.Int)>()
external void SetWindowMonitor(int monitor);

@ffi.Native<ffi.Void Function(ffi.Int, ffi.Int)>()
external void SetWindowMinSize(int width, int height);

@ffi.Native<ffi.Void Function(ffi.Int, ffi.Int)>()
external void SetWindowMaxSize(int width, int height);

@ffi.Native<ffi.Void Function(ffi.Int, ffi.Int)>()
external void SetWindowSize(int width, int height);

@ffi.Native<ffi.Void Function(ffi.Float)>()
external void SetWindowOpacity(double opacity);

@ffi.Native<ffi.Void Function()>()
external void SetWindowFocused();

@ffi.Native<ffi.Pointer<ffi.Void> Function()>()
external ffi.Pointer<ffi.Void> GetWindowHandle();

@ffi.Native<ffi.Int Function()>()
external int GetScreenWidth();

@ffi.Native<ffi.Int Function()>()
external int GetScreenHeight();

@ffi.Native<ffi.Int Function()>()
external int GetRenderWidth();

@ffi.Native<ffi.Int Function()>()
external int GetRenderHeight();

@ffi.Native<ffi.Int Function()>()
external int GetMonitorCount();

@ffi.Native<ffi.Int Function()>()
external int GetCurrentMonitor();

@ffi.Native<Vector2 Function(ffi.Int)>()
external Vector2 GetMonitorPosition(int monitor);

@ffi.Native<ffi.Int Function(ffi.Int)>()
external int GetMonitorWidth(int monitor);

@ffi.Native<ffi.Int Function(ffi.Int)>()
external int GetMonitorHeight(int monitor);

@ffi.Native<ffi.Int Function(ffi.Int)>()
external int GetMonitorPhysicalWidth(int monitor);

@ffi.Native<ffi.Int Function(ffi.Int)>()
external int GetMonitorPhysicalHeight(int monitor);

@ffi.Native<ffi.Int Function(ffi.Int)>()
external int GetMonitorRefreshRate(int monitor);

@ffi.Native<Vector2 Function()>()
external Vector2 GetWindowPosition();

@ffi.Native<Vector2 Function()>()
external Vector2 GetWindowScaleDPI();

@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Int)>()
external ffi.Pointer<ffi.Char> GetMonitorName(int monitor);

@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Char>)>()
external void SetClipboardText(ffi.Pointer<ffi.Char> text);

@ffi.Native<ffi.Pointer<ffi.Char> Function()>()
external ffi.Pointer<ffi.Char> GetClipboardText();

@ffi.Native<Image Function()>()
external Image GetClipboardImage();

@ffi.Native<ffi.Void Function()>()
external void EnableEventWaiting();

@ffi.Native<ffi.Void Function()>()
external void DisableEventWaiting();

@ffi.Native<ffi.Void Function()>()
external void ShowCursor();

@ffi.Native<ffi.Void Function()>()
external void HideCursor();

@ffi.Native<ffi.Bool Function()>()
external bool IsCursorHidden();

@ffi.Native<ffi.Void Function()>()
external void EnableCursor();

@ffi.Native<ffi.Void Function()>()
external void DisableCursor();

@ffi.Native<ffi.Bool Function()>()
external bool IsCursorOnScreen();

@ffi.Native<ffi.Void Function(Color)>()
external void ClearBackground(Color color);

@ffi.Native<ffi.Void Function()>()
external void BeginDrawing();

@ffi.Native<ffi.Void Function()>()
external void EndDrawing();

@ffi.Native<ffi.Void Function(Camera2D)>()
external void BeginMode2D(Camera2D camera);

@ffi.Native<ffi.Void Function()>()
external void EndMode2D();

@ffi.Native<ffi.Void Function(Camera3D)>()
external void BeginMode3D(Camera3D camera);

@ffi.Native<ffi.Void Function()>()
external void EndMode3D();

@ffi.Native<ffi.Void Function(RenderTexture2D)>()
external void BeginTextureMode(RenderTexture2D target);

@ffi.Native<ffi.Void Function()>()
external void EndTextureMode();

@ffi.Native<ffi.Void Function(Shader)>()
external void BeginShaderMode(Shader shader);

@ffi.Native<ffi.Void Function()>()
external void EndShaderMode();

@ffi.Native<ffi.Void Function(ffi.Int)>()
external void BeginBlendMode(int mode);

@ffi.Native<ffi.Void Function()>()
external void EndBlendMode();

@ffi.Native<ffi.Void Function(ffi.Int, ffi.Int, ffi.Int, ffi.Int)>()
external void BeginScissorMode(int x, int y, int width, int height);

@ffi.Native<ffi.Void Function()>()
external void EndScissorMode();

@ffi.Native<ffi.Void Function(VrStereoConfig)>()
external void BeginVrStereoMode(VrStereoConfig config);

@ffi.Native<ffi.Void Function()>()
external void EndVrStereoMode();

@ffi.Native<VrStereoConfig Function(VrDeviceInfo)>()
external VrStereoConfig LoadVrStereoConfig(VrDeviceInfo device);

@ffi.Native<ffi.Void Function(VrStereoConfig)>()
external void UnloadVrStereoConfig(VrStereoConfig config);

@ffi.Native<Shader Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>()
external Shader LoadShader(
  ffi.Pointer<ffi.Char> vsFileName,
  ffi.Pointer<ffi.Char> fsFileName,
);

@ffi.Native<Shader Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>()
external Shader LoadShaderFromMemory(
  ffi.Pointer<ffi.Char> vsCode,
  ffi.Pointer<ffi.Char> fsCode,
);

@ffi.Native<ffi.Bool Function(Shader)>()
external bool IsShaderValid(Shader shader);

@ffi.Native<ffi.Int Function(Shader, ffi.Pointer<ffi.Char>)>()
external int GetShaderLocation(
  Shader shader,
  ffi.Pointer<ffi.Char> uniformName,
);

@ffi.Native<ffi.Int Function(Shader, ffi.Pointer<ffi.Char>)>()
external int GetShaderLocationAttrib(
  Shader shader,
  ffi.Pointer<ffi.Char> attribName,
);

@ffi.Native<
  ffi.Void Function(Shader, ffi.Int, ffi.Pointer<ffi.Void>, ffi.Int)
>()
external void SetShaderValue(
  Shader shader,
  int locIndex,
  ffi.Pointer<ffi.Void> value,
  int uniformType,
);

@ffi.Native<
  ffi.Void Function(Shader, ffi.Int, ffi.Pointer<ffi.Void>, ffi.Int, ffi.Int)
>()
external void SetShaderValueV(
  Shader shader,
  int locIndex,
  ffi.Pointer<ffi.Void> value,
  int uniformType,
  int count,
);

@ffi.Native<ffi.Void Function(Shader, ffi.Int, Matrix)>()
external void SetShaderValueMatrix(Shader shader, int locIndex, Matrix mat);

@ffi.Native<ffi.Void Function(Shader, ffi.Int, Texture2D)>()
external void SetShaderValueTexture(
  Shader shader,
  int locIndex,
  Texture2D texture,
);

@ffi.Native<ffi.Void Function(Shader)>()
external void UnloadShader(Shader shader);

@ffi.Native<Ray Function(Vector2, Camera)>()
external Ray GetScreenToWorldRay(Vector2 position, Camera camera);

@ffi.Native<Ray Function(Vector2, Camera, ffi.Int, ffi.Int)>()
external Ray GetScreenToWorldRayEx(
  Vector2 position,
  Camera camera,
  int width,
  int height,
);

@ffi.Native<Vector2 Function(Vector3, Camera)>()
external Vector2 GetWorldToScreen(Vector3 position, Camera camera);

@ffi.Native<Vector2 Function(Vector3, Camera, ffi.Int, ffi.Int)>()
external Vector2 GetWorldToScreenEx(
  Vector3 position,
  Camera camera,
  int width,
  int height,
);

@ffi.Native<Vector2 Function(Vector2, Camera2D)>()
external Vector2 GetWorldToScreen2D(Vector2 position, Camera2D camera);

@ffi.Native<Vector2 Function(Vector2, Camera2D)>()
external Vector2 GetScreenToWorld2D(Vector2 position, Camera2D camera);

@ffi.Native<Matrix Function(Camera)>()
external Matrix GetCameraMatrix(Camera camera);

@ffi.Native<Matrix Function(Camera2D)>()
external Matrix GetCameraMatrix2D(Camera2D camera);

@ffi.Native<ffi.Void Function(ffi.Int)>()
external void SetTargetFPS(int fps);

@ffi.Native<ffi.Float Function()>()
external double GetFrameTime();

@ffi.Native<ffi.Double Function()>()
external double GetTime();

@ffi.Native<ffi.Int Function()>()
external int GetFPS();

@ffi.Native<ffi.Void Function()>()
external void SwapScreenBuffer();

@ffi.Native<ffi.Void Function()>()
external void PollInputEvents();

@ffi.Native<ffi.Void Function(ffi.Double)>()
external void WaitTime(double seconds);

@ffi.Native<ffi.Void Function(ffi.UnsignedInt)>()
external void SetRandomSeed(int seed);

@ffi.Native<ffi.Int Function(ffi.Int, ffi.Int)>()
external int GetRandomValue(int min, int max);

@ffi.Native<ffi.Pointer<ffi.Int> Function(ffi.UnsignedInt, ffi.Int, ffi.Int)>()
external ffi.Pointer<ffi.Int> LoadRandomSequence(int count, int min, int max);

@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Int>)>()
external void UnloadRandomSequence(ffi.Pointer<ffi.Int> sequence);

@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Char>)>()
external void TakeScreenshot(ffi.Pointer<ffi.Char> fileName);

@ffi.Native<ffi.Void Function(ffi.UnsignedInt)>()
external void SetConfigFlags(int flags);

@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Char>)>()
external void OpenURL(ffi.Pointer<ffi.Char> url);

@ffi.Native<ffi.Void Function(ffi.Int, ffi.Pointer<ffi.Char>)>()
external void TraceLog(int logLevel, ffi.Pointer<ffi.Char> text);

@ffi.Native<ffi.Void Function(ffi.Int)>()
external void SetTraceLogLevel(int logLevel);

@ffi.Native<ffi.Pointer<ffi.Void> Function(ffi.UnsignedInt)>()
external ffi.Pointer<ffi.Void> MemAlloc(int size);

@ffi.Native<
  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.UnsignedInt)
>()
external ffi.Pointer<ffi.Void> MemRealloc(ffi.Pointer<ffi.Void> ptr, int size);

@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Void>)>()
external void MemFree(ffi.Pointer<ffi.Void> ptr);

@ffi.Native<ffi.Void Function(TraceLogCallback)>()
external void SetTraceLogCallback(TraceLogCallback callback);

@ffi.Native<ffi.Void Function(LoadFileDataCallback)>()
external void SetLoadFileDataCallback(LoadFileDataCallback callback);

@ffi.Native<ffi.Void Function(SaveFileDataCallback)>()
external void SetSaveFileDataCallback(SaveFileDataCallback callback);

@ffi.Native<ffi.Void Function(LoadFileTextCallback)>()
external void SetLoadFileTextCallback(LoadFileTextCallback callback);

@ffi.Native<ffi.Void Function(SaveFileTextCallback)>()
external void SetSaveFileTextCallback(SaveFileTextCallback callback);

@ffi.Native<
  ffi.Pointer<ffi.UnsignedChar> Function(
    ffi.Pointer<ffi.Char>,
    ffi.Pointer<ffi.Int>,
  )
>()
external ffi.Pointer<ffi.UnsignedChar> LoadFileData(
  ffi.Pointer<ffi.Char> fileName,
  ffi.Pointer<ffi.Int> dataSize,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.UnsignedChar>)>()
external void UnloadFileData(ffi.Pointer<ffi.UnsignedChar> data);

@ffi.Native<
  ffi.Bool Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Void>, ffi.Int)
>()
external bool SaveFileData(
  ffi.Pointer<ffi.Char> fileName,
  ffi.Pointer<ffi.Void> data,
  int dataSize,
);

@ffi.Native<
  ffi.Bool Function(
    ffi.Pointer<ffi.UnsignedChar>,
    ffi.Int,
    ffi.Pointer<ffi.Char>,
  )
>()
external bool ExportDataAsCode(
  ffi.Pointer<ffi.UnsignedChar> data,
  int dataSize,
  ffi.Pointer<ffi.Char> fileName,
);

@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>()
external ffi.Pointer<ffi.Char> LoadFileText(ffi.Pointer<ffi.Char> fileName);

@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Char>)>()
external void UnloadFileText(ffi.Pointer<ffi.Char> text);

@ffi.Native<ffi.Bool Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>()
external bool SaveFileText(
  ffi.Pointer<ffi.Char> fileName,
  ffi.Pointer<ffi.Char> text,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>()
external int FileRename(
  ffi.Pointer<ffi.Char> fileName,
  ffi.Pointer<ffi.Char> fileRename,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Char>)>()
external int FileRemove(ffi.Pointer<ffi.Char> fileName);

@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>()
external int FileCopy(
  ffi.Pointer<ffi.Char> srcPath,
  ffi.Pointer<ffi.Char> dstPath,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>()
external int FileMove(
  ffi.Pointer<ffi.Char> srcPath,
  ffi.Pointer<ffi.Char> dstPath,
);

@ffi.Native<
  ffi.Int Function(
    ffi.Pointer<ffi.Char>,
    ffi.Pointer<ffi.Char>,
    ffi.Pointer<ffi.Char>,
  )
>()
external int FileTextReplace(
  ffi.Pointer<ffi.Char> fileName,
  ffi.Pointer<ffi.Char> search,
  ffi.Pointer<ffi.Char> replacement,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>()
external int FileTextFindIndex(
  ffi.Pointer<ffi.Char> fileName,
  ffi.Pointer<ffi.Char> search,
);

@ffi.Native<ffi.Bool Function(ffi.Pointer<ffi.Char>)>()
external bool FileExists(ffi.Pointer<ffi.Char> fileName);

@ffi.Native<ffi.Bool Function(ffi.Pointer<ffi.Char>)>()
external bool DirectoryExists(ffi.Pointer<ffi.Char> dirPath);

@ffi.Native<ffi.Bool Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>()
external bool IsFileExtension(
  ffi.Pointer<ffi.Char> fileName,
  ffi.Pointer<ffi.Char> ext,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Char>)>()
external int GetFileLength(ffi.Pointer<ffi.Char> fileName);

@ffi.Native<ffi.Long Function(ffi.Pointer<ffi.Char>)>()
external int GetFileModTime(ffi.Pointer<ffi.Char> fileName);

@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>()
external ffi.Pointer<ffi.Char> GetFileExtension(ffi.Pointer<ffi.Char> fileName);

@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>()
external ffi.Pointer<ffi.Char> GetFileName(ffi.Pointer<ffi.Char> filePath);

@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>()
external ffi.Pointer<ffi.Char> GetFileNameWithoutExt(
  ffi.Pointer<ffi.Char> filePath,
);

@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>()
external ffi.Pointer<ffi.Char> GetDirectoryPath(ffi.Pointer<ffi.Char> filePath);

@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>()
external ffi.Pointer<ffi.Char> GetPrevDirectoryPath(
  ffi.Pointer<ffi.Char> dirPath,
);

@ffi.Native<ffi.Pointer<ffi.Char> Function()>()
external ffi.Pointer<ffi.Char> GetWorkingDirectory();

@ffi.Native<ffi.Pointer<ffi.Char> Function()>()
external ffi.Pointer<ffi.Char> GetApplicationDirectory();

@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Char>)>()
external int MakeDirectory(ffi.Pointer<ffi.Char> dirPath);

@ffi.Native<ffi.Bool Function(ffi.Pointer<ffi.Char>)>()
external bool ChangeDirectory(ffi.Pointer<ffi.Char> dir);

@ffi.Native<ffi.Bool Function(ffi.Pointer<ffi.Char>)>()
external bool IsPathFile(ffi.Pointer<ffi.Char> path);

@ffi.Native<ffi.Bool Function(ffi.Pointer<ffi.Char>)>()
external bool IsFileNameValid(ffi.Pointer<ffi.Char> fileName);

@ffi.Native<FilePathList Function(ffi.Pointer<ffi.Char>)>()
external FilePathList LoadDirectoryFiles(ffi.Pointer<ffi.Char> dirPath);

@ffi.Native<
  FilePathList Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, ffi.Bool)
>()
external FilePathList LoadDirectoryFilesEx(
  ffi.Pointer<ffi.Char> basePath,
  ffi.Pointer<ffi.Char> filter,
  bool scanSubdirs,
);

@ffi.Native<ffi.Void Function(FilePathList)>()
external void UnloadDirectoryFiles(FilePathList files);

@ffi.Native<ffi.Bool Function()>()
external bool IsFileDropped();

@ffi.Native<FilePathList Function()>()
external FilePathList LoadDroppedFiles();

@ffi.Native<ffi.Void Function(FilePathList)>()
external void UnloadDroppedFiles(FilePathList files);

@ffi.Native<
  ffi.Pointer<ffi.UnsignedChar> Function(
    ffi.Pointer<ffi.UnsignedChar>,
    ffi.Int,
    ffi.Pointer<ffi.Int>,
  )
>()
external ffi.Pointer<ffi.UnsignedChar> CompressData(
  ffi.Pointer<ffi.UnsignedChar> data,
  int dataSize,
  ffi.Pointer<ffi.Int> compDataSize,
);

@ffi.Native<
  ffi.Pointer<ffi.UnsignedChar> Function(
    ffi.Pointer<ffi.UnsignedChar>,
    ffi.Int,
    ffi.Pointer<ffi.Int>,
  )
>()
external ffi.Pointer<ffi.UnsignedChar> DecompressData(
  ffi.Pointer<ffi.UnsignedChar> compData,
  int compDataSize,
  ffi.Pointer<ffi.Int> dataSize,
);

@ffi.Native<
  ffi.Pointer<ffi.Char> Function(
    ffi.Pointer<ffi.UnsignedChar>,
    ffi.Int,
    ffi.Pointer<ffi.Int>,
  )
>()
external ffi.Pointer<ffi.Char> EncodeDataBase64(
  ffi.Pointer<ffi.UnsignedChar> data,
  int dataSize,
  ffi.Pointer<ffi.Int> outputSize,
);

@ffi.Native<
  ffi.Pointer<ffi.UnsignedChar> Function(
    ffi.Pointer<ffi.Char>,
    ffi.Pointer<ffi.Int>,
  )
>()
external ffi.Pointer<ffi.UnsignedChar> DecodeDataBase64(
  ffi.Pointer<ffi.Char> text,
  ffi.Pointer<ffi.Int> outputSize,
);

@ffi.Native<ffi.UnsignedInt Function(ffi.Pointer<ffi.UnsignedChar>, ffi.Int)>()
external int ComputeCRC32(ffi.Pointer<ffi.UnsignedChar> data, int dataSize);

@ffi.Native<
  ffi.Pointer<ffi.UnsignedInt> Function(ffi.Pointer<ffi.UnsignedChar>, ffi.Int)
>()
external ffi.Pointer<ffi.UnsignedInt> ComputeMD5(
  ffi.Pointer<ffi.UnsignedChar> data,
  int dataSize,
);

@ffi.Native<
  ffi.Pointer<ffi.UnsignedInt> Function(ffi.Pointer<ffi.UnsignedChar>, ffi.Int)
>()
external ffi.Pointer<ffi.UnsignedInt> ComputeSHA1(
  ffi.Pointer<ffi.UnsignedChar> data,
  int dataSize,
);

@ffi.Native<
  ffi.Pointer<ffi.UnsignedInt> Function(ffi.Pointer<ffi.UnsignedChar>, ffi.Int)
>()
external ffi.Pointer<ffi.UnsignedInt> ComputeSHA256(
  ffi.Pointer<ffi.UnsignedChar> data,
  int dataSize,
);

@ffi.Native<AutomationEventList Function(ffi.Pointer<ffi.Char>)>()
external AutomationEventList LoadAutomationEventList(
  ffi.Pointer<ffi.Char> fileName,
);

@ffi.Native<ffi.Void Function(AutomationEventList)>()
external void UnloadAutomationEventList(AutomationEventList list);

@ffi.Native<ffi.Bool Function(AutomationEventList, ffi.Pointer<ffi.Char>)>()
external bool ExportAutomationEventList(
  AutomationEventList list,
  ffi.Pointer<ffi.Char> fileName,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<AutomationEventList>)>()
external void SetAutomationEventList(ffi.Pointer<AutomationEventList> list);

@ffi.Native<ffi.Void Function(ffi.Int)>()
external void SetAutomationEventBaseFrame(int frame);

@ffi.Native<ffi.Void Function()>()
external void StartAutomationEventRecording();

@ffi.Native<ffi.Void Function()>()
external void StopAutomationEventRecording();

@ffi.Native<ffi.Void Function(AutomationEvent)>()
external void PlayAutomationEvent(AutomationEvent event);

@ffi.Native<ffi.Bool Function(ffi.Int)>()
external bool IsKeyPressed(int key);

@ffi.Native<ffi.Bool Function(ffi.Int)>()
external bool IsKeyPressedRepeat(int key);

@ffi.Native<ffi.Bool Function(ffi.Int)>()
external bool IsKeyDown(int key);

@ffi.Native<ffi.Bool Function(ffi.Int)>()
external bool IsKeyReleased(int key);

@ffi.Native<ffi.Bool Function(ffi.Int)>()
external bool IsKeyUp(int key);

@ffi.Native<ffi.Int Function()>()
external int GetKeyPressed();

@ffi.Native<ffi.Int Function()>()
external int GetCharPressed();

@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Int)>()
external ffi.Pointer<ffi.Char> GetKeyName(int key);

@ffi.Native<ffi.Void Function(ffi.Int)>()
external void SetExitKey(int key);

@ffi.Native<ffi.Bool Function(ffi.Int)>()
external bool IsGamepadAvailable(int gamepad);

@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Int)>()
external ffi.Pointer<ffi.Char> GetGamepadName(int gamepad);

@ffi.Native<ffi.Bool Function(ffi.Int, ffi.Int)>()
external bool IsGamepadButtonPressed(int gamepad, int button);

@ffi.Native<ffi.Bool Function(ffi.Int, ffi.Int)>()
external bool IsGamepadButtonDown(int gamepad, int button);

@ffi.Native<ffi.Bool Function(ffi.Int, ffi.Int)>()
external bool IsGamepadButtonReleased(int gamepad, int button);

@ffi.Native<ffi.Bool Function(ffi.Int, ffi.Int)>()
external bool IsGamepadButtonUp(int gamepad, int button);

@ffi.Native<ffi.Int Function()>()
external int GetGamepadButtonPressed();

@ffi.Native<ffi.Int Function(ffi.Int)>()
external int GetGamepadAxisCount(int gamepad);

@ffi.Native<ffi.Float Function(ffi.Int, ffi.Int)>()
external double GetGamepadAxisMovement(int gamepad, int axis);

@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Char>)>()
external int SetGamepadMappings(ffi.Pointer<ffi.Char> mappings);

@ffi.Native<ffi.Void Function(ffi.Int, ffi.Float, ffi.Float, ffi.Float)>()
external void SetGamepadVibration(
  int gamepad,
  double leftMotor,
  double rightMotor,
  double duration,
);

@ffi.Native<ffi.Bool Function(ffi.Int)>()
external bool IsMouseButtonPressed(int button);

@ffi.Native<ffi.Bool Function(ffi.Int)>()
external bool IsMouseButtonDown(int button);

@ffi.Native<ffi.Bool Function(ffi.Int)>()
external bool IsMouseButtonReleased(int button);

@ffi.Native<ffi.Bool Function(ffi.Int)>()
external bool IsMouseButtonUp(int button);

@ffi.Native<ffi.Int Function()>()
external int GetMouseX();

@ffi.Native<ffi.Int Function()>()
external int GetMouseY();

@ffi.Native<Vector2 Function()>()
external Vector2 GetMousePosition();

@ffi.Native<Vector2 Function()>()
external Vector2 GetMouseDelta();

@ffi.Native<ffi.Void Function(ffi.Int, ffi.Int)>()
external void SetMousePosition(int x, int y);

@ffi.Native<ffi.Void Function(ffi.Int, ffi.Int)>()
external void SetMouseOffset(int offsetX, int offsetY);

@ffi.Native<ffi.Void Function(ffi.Float, ffi.Float)>()
external void SetMouseScale(double scaleX, double scaleY);

@ffi.Native<ffi.Float Function()>()
external double GetMouseWheelMove();

@ffi.Native<Vector2 Function()>()
external Vector2 GetMouseWheelMoveV();

@ffi.Native<ffi.Void Function(ffi.Int)>()
external void SetMouseCursor(int cursor);

@ffi.Native<ffi.Int Function()>()
external int GetTouchX();

@ffi.Native<ffi.Int Function()>()
external int GetTouchY();

@ffi.Native<Vector2 Function(ffi.Int)>()
external Vector2 GetTouchPosition(int index);

@ffi.Native<ffi.Int Function(ffi.Int)>()
external int GetTouchPointId(int index);

@ffi.Native<ffi.Int Function()>()
external int GetTouchPointCount();

@ffi.Native<ffi.Void Function(ffi.UnsignedInt)>()
external void SetGesturesEnabled(int flags);

@ffi.Native<ffi.Bool Function(ffi.UnsignedInt)>()
external bool IsGestureDetected(int gesture);

@ffi.Native<ffi.Int Function()>()
external int GetGestureDetected();

@ffi.Native<ffi.Float Function()>()
external double GetGestureHoldDuration();

@ffi.Native<Vector2 Function()>()
external Vector2 GetGestureDragVector();

@ffi.Native<ffi.Float Function()>()
external double GetGestureDragAngle();

@ffi.Native<Vector2 Function()>()
external Vector2 GetGesturePinchVector();

@ffi.Native<ffi.Float Function()>()
external double GetGesturePinchAngle();

@ffi.Native<ffi.Void Function(ffi.Pointer<Camera>, ffi.Int)>()
external void UpdateCamera(ffi.Pointer<Camera> camera, int mode);

@ffi.Native<
  ffi.Void Function(ffi.Pointer<Camera>, Vector3, Vector3, ffi.Float)
>()
external void UpdateCameraPro(
  ffi.Pointer<Camera> camera,
  Vector3 movement,
  Vector3 rotation,
  double zoom,
);

@ffi.Native<ffi.Void Function(Texture2D, Rectangle)>()
external void SetShapesTexture(Texture2D texture, Rectangle source);

@ffi.Native<Texture2D Function()>()
external Texture2D GetShapesTexture();

@ffi.Native<Rectangle Function()>()
external Rectangle GetShapesTextureRectangle();

@ffi.Native<ffi.Void Function(ffi.Int, ffi.Int, Color)>()
external void DrawPixel(int posX, int posY, Color color);

@ffi.Native<ffi.Void Function(Vector2, Color)>()
external void DrawPixelV(Vector2 position, Color color);

@ffi.Native<ffi.Void Function(ffi.Int, ffi.Int, ffi.Int, ffi.Int, Color)>()
external void DrawLine(
  int startPosX,
  int startPosY,
  int endPosX,
  int endPosY,
  Color color,
);

@ffi.Native<ffi.Void Function(Vector2, Vector2, Color)>()
external void DrawLineV(Vector2 startPos, Vector2 endPos, Color color);

@ffi.Native<ffi.Void Function(Vector2, Vector2, ffi.Float, Color)>()
external void DrawLineEx(
  Vector2 startPos,
  Vector2 endPos,
  double thick,
  Color color,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<Vector2>, ffi.Int, Color)>()
external void DrawLineStrip(
  ffi.Pointer<Vector2> points,
  int pointCount,
  Color color,
);

@ffi.Native<ffi.Void Function(Vector2, Vector2, ffi.Float, Color)>()
external void DrawLineBezier(
  Vector2 startPos,
  Vector2 endPos,
  double thick,
  Color color,
);

@ffi.Native<ffi.Void Function(Vector2, Vector2, ffi.Int, ffi.Int, Color)>()
external void DrawLineDashed(
  Vector2 startPos,
  Vector2 endPos,
  int dashSize,
  int spaceSize,
  Color color,
);

@ffi.Native<ffi.Void Function(ffi.Int, ffi.Int, ffi.Float, Color)>()
external void DrawCircle(int centerX, int centerY, double radius, Color color);

@ffi.Native<
  ffi.Void Function(Vector2, ffi.Float, ffi.Float, ffi.Float, ffi.Int, Color)
>()
external void DrawCircleSector(
  Vector2 center,
  double radius,
  double startAngle,
  double endAngle,
  int segments,
  Color color,
);

@ffi.Native<
  ffi.Void Function(Vector2, ffi.Float, ffi.Float, ffi.Float, ffi.Int, Color)
>()
external void DrawCircleSectorLines(
  Vector2 center,
  double radius,
  double startAngle,
  double endAngle,
  int segments,
  Color color,
);

@ffi.Native<ffi.Void Function(ffi.Int, ffi.Int, ffi.Float, Color, Color)>()
external void DrawCircleGradient(
  int centerX,
  int centerY,
  double radius,
  Color inner,
  Color outer,
);

@ffi.Native<ffi.Void Function(Vector2, ffi.Float, Color)>()
external void DrawCircleV(Vector2 center, double radius, Color color);

@ffi.Native<ffi.Void Function(ffi.Int, ffi.Int, ffi.Float, Color)>()
external void DrawCircleLines(
  int centerX,
  int centerY,
  double radius,
  Color color,
);

@ffi.Native<ffi.Void Function(Vector2, ffi.Float, Color)>()
external void DrawCircleLinesV(Vector2 center, double radius, Color color);

@ffi.Native<ffi.Void Function(ffi.Int, ffi.Int, ffi.Float, ffi.Float, Color)>()
external void DrawEllipse(
  int centerX,
  int centerY,
  double radiusH,
  double radiusV,
  Color color,
);

@ffi.Native<ffi.Void Function(Vector2, ffi.Float, ffi.Float, Color)>()
external void DrawEllipseV(
  Vector2 center,
  double radiusH,
  double radiusV,
  Color color,
);

@ffi.Native<ffi.Void Function(ffi.Int, ffi.Int, ffi.Float, ffi.Float, Color)>()
external void DrawEllipseLines(
  int centerX,
  int centerY,
  double radiusH,
  double radiusV,
  Color color,
);

@ffi.Native<ffi.Void Function(Vector2, ffi.Float, ffi.Float, Color)>()
external void DrawEllipseLinesV(
  Vector2 center,
  double radiusH,
  double radiusV,
  Color color,
);

@ffi.Native<
  ffi.Void Function(
    Vector2,
    ffi.Float,
    ffi.Float,
    ffi.Float,
    ffi.Float,
    ffi.Int,
    Color,
  )
>()
external void DrawRing(
  Vector2 center,
  double innerRadius,
  double outerRadius,
  double startAngle,
  double endAngle,
  int segments,
  Color color,
);

@ffi.Native<
  ffi.Void Function(
    Vector2,
    ffi.Float,
    ffi.Float,
    ffi.Float,
    ffi.Float,
    ffi.Int,
    Color,
  )
>()
external void DrawRingLines(
  Vector2 center,
  double innerRadius,
  double outerRadius,
  double startAngle,
  double endAngle,
  int segments,
  Color color,
);

@ffi.Native<ffi.Void Function(ffi.Int, ffi.Int, ffi.Int, ffi.Int, Color)>()
external void DrawRectangle(
  int posX,
  int posY,
  int width,
  int height,
  Color color,
);

@ffi.Native<ffi.Void Function(Vector2, Vector2, Color)>()
external void DrawRectangleV(Vector2 position, Vector2 size, Color color);

@ffi.Native<ffi.Void Function(Rectangle, Color)>()
external void DrawRectangleRec(Rectangle rec, Color color);

@ffi.Native<ffi.Void Function(Rectangle, Vector2, ffi.Float, Color)>()
external void DrawRectanglePro(
  Rectangle rec,
  Vector2 origin,
  double rotation,
  Color color,
);

@ffi.Native<
  ffi.Void Function(ffi.Int, ffi.Int, ffi.Int, ffi.Int, Color, Color)
>()
external void DrawRectangleGradientV(
  int posX,
  int posY,
  int width,
  int height,
  Color top,
  Color bottom,
);

@ffi.Native<
  ffi.Void Function(ffi.Int, ffi.Int, ffi.Int, ffi.Int, Color, Color)
>()
external void DrawRectangleGradientH(
  int posX,
  int posY,
  int width,
  int height,
  Color left,
  Color right,
);

@ffi.Native<ffi.Void Function(Rectangle, Color, Color, Color, Color)>()
external void DrawRectangleGradientEx(
  Rectangle rec,
  Color topLeft,
  Color bottomLeft,
  Color bottomRight,
  Color topRight,
);

@ffi.Native<ffi.Void Function(ffi.Int, ffi.Int, ffi.Int, ffi.Int, Color)>()
external void DrawRectangleLines(
  int posX,
  int posY,
  int width,
  int height,
  Color color,
);

@ffi.Native<ffi.Void Function(Rectangle, ffi.Float, Color)>()
external void DrawRectangleLinesEx(
  Rectangle rec,
  double lineThick,
  Color color,
);

@ffi.Native<ffi.Void Function(Rectangle, ffi.Float, ffi.Int, Color)>()
external void DrawRectangleRounded(
  Rectangle rec,
  double roundness,
  int segments,
  Color color,
);

@ffi.Native<ffi.Void Function(Rectangle, ffi.Float, ffi.Int, Color)>()
external void DrawRectangleRoundedLines(
  Rectangle rec,
  double roundness,
  int segments,
  Color color,
);

@ffi.Native<
  ffi.Void Function(Rectangle, ffi.Float, ffi.Int, ffi.Float, Color)
>()
external void DrawRectangleRoundedLinesEx(
  Rectangle rec,
  double roundness,
  int segments,
  double lineThick,
  Color color,
);

@ffi.Native<ffi.Void Function(Vector2, Vector2, Vector2, Color)>()
external void DrawTriangle(Vector2 v1, Vector2 v2, Vector2 v3, Color color);

@ffi.Native<ffi.Void Function(Vector2, Vector2, Vector2, Color)>()
external void DrawTriangleLines(
  Vector2 v1,
  Vector2 v2,
  Vector2 v3,
  Color color,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<Vector2>, ffi.Int, Color)>()
external void DrawTriangleFan(
  ffi.Pointer<Vector2> points,
  int pointCount,
  Color color,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<Vector2>, ffi.Int, Color)>()
external void DrawTriangleStrip(
  ffi.Pointer<Vector2> points,
  int pointCount,
  Color color,
);

@ffi.Native<ffi.Void Function(Vector2, ffi.Int, ffi.Float, ffi.Float, Color)>()
external void DrawPoly(
  Vector2 center,
  int sides,
  double radius,
  double rotation,
  Color color,
);

@ffi.Native<ffi.Void Function(Vector2, ffi.Int, ffi.Float, ffi.Float, Color)>()
external void DrawPolyLines(
  Vector2 center,
  int sides,
  double radius,
  double rotation,
  Color color,
);

@ffi.Native<
  ffi.Void Function(Vector2, ffi.Int, ffi.Float, ffi.Float, ffi.Float, Color)
>()
external void DrawPolyLinesEx(
  Vector2 center,
  int sides,
  double radius,
  double rotation,
  double lineThick,
  Color color,
);

@ffi.Native<
  ffi.Void Function(ffi.Pointer<Vector2>, ffi.Int, ffi.Float, Color)
>()
external void DrawSplineLinear(
  ffi.Pointer<Vector2> points,
  int pointCount,
  double thick,
  Color color,
);

@ffi.Native<
  ffi.Void Function(ffi.Pointer<Vector2>, ffi.Int, ffi.Float, Color)
>()
external void DrawSplineBasis(
  ffi.Pointer<Vector2> points,
  int pointCount,
  double thick,
  Color color,
);

@ffi.Native<
  ffi.Void Function(ffi.Pointer<Vector2>, ffi.Int, ffi.Float, Color)
>()
external void DrawSplineCatmullRom(
  ffi.Pointer<Vector2> points,
  int pointCount,
  double thick,
  Color color,
);

@ffi.Native<
  ffi.Void Function(ffi.Pointer<Vector2>, ffi.Int, ffi.Float, Color)
>()
external void DrawSplineBezierQuadratic(
  ffi.Pointer<Vector2> points,
  int pointCount,
  double thick,
  Color color,
);

@ffi.Native<
  ffi.Void Function(ffi.Pointer<Vector2>, ffi.Int, ffi.Float, Color)
>()
external void DrawSplineBezierCubic(
  ffi.Pointer<Vector2> points,
  int pointCount,
  double thick,
  Color color,
);

@ffi.Native<ffi.Void Function(Vector2, Vector2, ffi.Float, Color)>()
external void DrawSplineSegmentLinear(
  Vector2 p1,
  Vector2 p2,
  double thick,
  Color color,
);

@ffi.Native<
  ffi.Void Function(Vector2, Vector2, Vector2, Vector2, ffi.Float, Color)
>()
external void DrawSplineSegmentBasis(
  Vector2 p1,
  Vector2 p2,
  Vector2 p3,
  Vector2 p4,
  double thick,
  Color color,
);

@ffi.Native<
  ffi.Void Function(Vector2, Vector2, Vector2, Vector2, ffi.Float, Color)
>()
external void DrawSplineSegmentCatmullRom(
  Vector2 p1,
  Vector2 p2,
  Vector2 p3,
  Vector2 p4,
  double thick,
  Color color,
);

@ffi.Native<ffi.Void Function(Vector2, Vector2, Vector2, ffi.Float, Color)>()
external void DrawSplineSegmentBezierQuadratic(
  Vector2 p1,
  Vector2 c2,
  Vector2 p3,
  double thick,
  Color color,
);

@ffi.Native<
  ffi.Void Function(Vector2, Vector2, Vector2, Vector2, ffi.Float, Color)
>()
external void DrawSplineSegmentBezierCubic(
  Vector2 p1,
  Vector2 c2,
  Vector2 c3,
  Vector2 p4,
  double thick,
  Color color,
);

@ffi.Native<Vector2 Function(Vector2, Vector2, ffi.Float)>()
external Vector2 GetSplinePointLinear(
  Vector2 startPos,
  Vector2 endPos,
  double t,
);

@ffi.Native<Vector2 Function(Vector2, Vector2, Vector2, Vector2, ffi.Float)>()
external Vector2 GetSplinePointBasis(
  Vector2 p1,
  Vector2 p2,
  Vector2 p3,
  Vector2 p4,
  double t,
);

@ffi.Native<Vector2 Function(Vector2, Vector2, Vector2, Vector2, ffi.Float)>()
external Vector2 GetSplinePointCatmullRom(
  Vector2 p1,
  Vector2 p2,
  Vector2 p3,
  Vector2 p4,
  double t,
);

@ffi.Native<Vector2 Function(Vector2, Vector2, Vector2, ffi.Float)>()
external Vector2 GetSplinePointBezierQuad(
  Vector2 p1,
  Vector2 c2,
  Vector2 p3,
  double t,
);

@ffi.Native<Vector2 Function(Vector2, Vector2, Vector2, Vector2, ffi.Float)>()
external Vector2 GetSplinePointBezierCubic(
  Vector2 p1,
  Vector2 c2,
  Vector2 c3,
  Vector2 p4,
  double t,
);

@ffi.Native<ffi.Bool Function(Rectangle, Rectangle)>()
external bool CheckCollisionRecs(Rectangle rec1, Rectangle rec2);

@ffi.Native<ffi.Bool Function(Vector2, ffi.Float, Vector2, ffi.Float)>()
external bool CheckCollisionCircles(
  Vector2 center1,
  double radius1,
  Vector2 center2,
  double radius2,
);

@ffi.Native<ffi.Bool Function(Vector2, ffi.Float, Rectangle)>()
external bool CheckCollisionCircleRec(
  Vector2 center,
  double radius,
  Rectangle rec,
);

@ffi.Native<ffi.Bool Function(Vector2, ffi.Float, Vector2, Vector2)>()
external bool CheckCollisionCircleLine(
  Vector2 center,
  double radius,
  Vector2 p1,
  Vector2 p2,
);

@ffi.Native<ffi.Bool Function(Vector2, Rectangle)>()
external bool CheckCollisionPointRec(Vector2 point, Rectangle rec);

@ffi.Native<ffi.Bool Function(Vector2, Vector2, ffi.Float)>()
external bool CheckCollisionPointCircle(
  Vector2 point,
  Vector2 center,
  double radius,
);

@ffi.Native<ffi.Bool Function(Vector2, Vector2, Vector2, Vector2)>()
external bool CheckCollisionPointTriangle(
  Vector2 point,
  Vector2 p1,
  Vector2 p2,
  Vector2 p3,
);

@ffi.Native<ffi.Bool Function(Vector2, Vector2, Vector2, ffi.Int)>()
external bool CheckCollisionPointLine(
  Vector2 point,
  Vector2 p1,
  Vector2 p2,
  int threshold,
);

@ffi.Native<ffi.Bool Function(Vector2, ffi.Pointer<Vector2>, ffi.Int)>()
external bool CheckCollisionPointPoly(
  Vector2 point,
  ffi.Pointer<Vector2> points,
  int pointCount,
);

@ffi.Native<
  ffi.Bool Function(Vector2, Vector2, Vector2, Vector2, ffi.Pointer<Vector2>)
>()
external bool CheckCollisionLines(
  Vector2 startPos1,
  Vector2 endPos1,
  Vector2 startPos2,
  Vector2 endPos2,
  ffi.Pointer<Vector2> collisionPoint,
);

@ffi.Native<Rectangle Function(Rectangle, Rectangle)>()
external Rectangle GetCollisionRec(Rectangle rec1, Rectangle rec2);

@ffi.Native<Image Function(ffi.Pointer<ffi.Char>)>()
external Image LoadImage(ffi.Pointer<ffi.Char> fileName);

@ffi.Native<
  Image Function(ffi.Pointer<ffi.Char>, ffi.Int, ffi.Int, ffi.Int, ffi.Int)
>()
external Image LoadImageRaw(
  ffi.Pointer<ffi.Char> fileName,
  int width,
  int height,
  int format,
  int headerSize,
);

@ffi.Native<Image Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Int>)>()
external Image LoadImageAnim(
  ffi.Pointer<ffi.Char> fileName,
  ffi.Pointer<ffi.Int> frames,
);

@ffi.Native<
  Image Function(
    ffi.Pointer<ffi.Char>,
    ffi.Pointer<ffi.UnsignedChar>,
    ffi.Int,
    ffi.Pointer<ffi.Int>,
  )
>()
external Image LoadImageAnimFromMemory(
  ffi.Pointer<ffi.Char> fileType,
  ffi.Pointer<ffi.UnsignedChar> fileData,
  int dataSize,
  ffi.Pointer<ffi.Int> frames,
);

@ffi.Native<
  Image Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.UnsignedChar>, ffi.Int)
>()
external Image LoadImageFromMemory(
  ffi.Pointer<ffi.Char> fileType,
  ffi.Pointer<ffi.UnsignedChar> fileData,
  int dataSize,
);

@ffi.Native<Image Function(Texture2D)>()
external Image LoadImageFromTexture(Texture2D texture);

@ffi.Native<Image Function()>()
external Image LoadImageFromScreen();

@ffi.Native<ffi.Bool Function(Image)>()
external bool IsImageValid(Image image);

@ffi.Native<ffi.Void Function(Image)>()
external void UnloadImage(Image image);

@ffi.Native<ffi.Bool Function(Image, ffi.Pointer<ffi.Char>)>()
external bool ExportImage(Image image, ffi.Pointer<ffi.Char> fileName);

@ffi.Native<
  ffi.Pointer<ffi.UnsignedChar> Function(
    Image,
    ffi.Pointer<ffi.Char>,
    ffi.Pointer<ffi.Int>,
  )
>()
external ffi.Pointer<ffi.UnsignedChar> ExportImageToMemory(
  Image image,
  ffi.Pointer<ffi.Char> fileType,
  ffi.Pointer<ffi.Int> fileSize,
);

@ffi.Native<ffi.Bool Function(Image, ffi.Pointer<ffi.Char>)>()
external bool ExportImageAsCode(Image image, ffi.Pointer<ffi.Char> fileName);

@ffi.Native<Image Function(ffi.Int, ffi.Int, Color)>()
external Image GenImageColor(int width, int height, Color color);

@ffi.Native<Image Function(ffi.Int, ffi.Int, ffi.Int, Color, Color)>()
external Image GenImageGradientLinear(
  int width,
  int height,
  int direction,
  Color start,
  Color end,
);

@ffi.Native<Image Function(ffi.Int, ffi.Int, ffi.Float, Color, Color)>()
external Image GenImageGradientRadial(
  int width,
  int height,
  double density,
  Color inner,
  Color outer,
);

@ffi.Native<Image Function(ffi.Int, ffi.Int, ffi.Float, Color, Color)>()
external Image GenImageGradientSquare(
  int width,
  int height,
  double density,
  Color inner,
  Color outer,
);

@ffi.Native<Image Function(ffi.Int, ffi.Int, ffi.Int, ffi.Int, Color, Color)>()
external Image GenImageChecked(
  int width,
  int height,
  int checksX,
  int checksY,
  Color col1,
  Color col2,
);

@ffi.Native<Image Function(ffi.Int, ffi.Int, ffi.Float)>()
external Image GenImageWhiteNoise(int width, int height, double factor);

@ffi.Native<Image Function(ffi.Int, ffi.Int, ffi.Int, ffi.Int, ffi.Float)>()
external Image GenImagePerlinNoise(
  int width,
  int height,
  int offsetX,
  int offsetY,
  double scale,
);

@ffi.Native<Image Function(ffi.Int, ffi.Int, ffi.Int)>()
external Image GenImageCellular(int width, int height, int tileSize);

@ffi.Native<Image Function(ffi.Int, ffi.Int, ffi.Pointer<ffi.Char>)>()
external Image GenImageText(int width, int height, ffi.Pointer<ffi.Char> text);

@ffi.Native<Image Function(Image)>()
external Image ImageCopy(Image image);

@ffi.Native<Image Function(Image, Rectangle)>()
external Image ImageFromImage(Image image, Rectangle rec);

@ffi.Native<Image Function(Image, ffi.Int)>()
external Image ImageFromChannel(Image image, int selectedChannel);

@ffi.Native<Image Function(ffi.Pointer<ffi.Char>, ffi.Int, Color)>()
external Image ImageText(ffi.Pointer<ffi.Char> text, int fontSize, Color color);

@ffi.Native<
  Image Function(Font, ffi.Pointer<ffi.Char>, ffi.Float, ffi.Float, Color)
>()
external Image ImageTextEx(
  Font font,
  ffi.Pointer<ffi.Char> text,
  double fontSize,
  double spacing,
  Color tint,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<Image>, ffi.Int)>()
external void ImageFormat(ffi.Pointer<Image> image, int newFormat);

@ffi.Native<ffi.Void Function(ffi.Pointer<Image>, Color)>()
external void ImageToPOT(ffi.Pointer<Image> image, Color fill);

@ffi.Native<ffi.Void Function(ffi.Pointer<Image>, Rectangle)>()
external void ImageCrop(ffi.Pointer<Image> image, Rectangle crop);

@ffi.Native<ffi.Void Function(ffi.Pointer<Image>, ffi.Float)>()
external void ImageAlphaCrop(ffi.Pointer<Image> image, double threshold);

@ffi.Native<ffi.Void Function(ffi.Pointer<Image>, Color, ffi.Float)>()
external void ImageAlphaClear(
  ffi.Pointer<Image> image,
  Color color,
  double threshold,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<Image>, Image)>()
external void ImageAlphaMask(ffi.Pointer<Image> image, Image alphaMask);

@ffi.Native<ffi.Void Function(ffi.Pointer<Image>)>()
external void ImageAlphaPremultiply(ffi.Pointer<Image> image);

@ffi.Native<ffi.Void Function(ffi.Pointer<Image>, ffi.Int)>()
external void ImageBlurGaussian(ffi.Pointer<Image> image, int blurSize);

@ffi.Native<
  ffi.Void Function(ffi.Pointer<Image>, ffi.Pointer<ffi.Float>, ffi.Int)
>()
external void ImageKernelConvolution(
  ffi.Pointer<Image> image,
  ffi.Pointer<ffi.Float> kernel,
  int kernelSize,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<Image>, ffi.Int, ffi.Int)>()
external void ImageResize(
  ffi.Pointer<Image> image,
  int newWidth,
  int newHeight,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<Image>, ffi.Int, ffi.Int)>()
external void ImageResizeNN(
  ffi.Pointer<Image> image,
  int newWidth,
  int newHeight,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<Image>,
    ffi.Int,
    ffi.Int,
    ffi.Int,
    ffi.Int,
    Color,
  )
>()
external void ImageResizeCanvas(
  ffi.Pointer<Image> image,
  int newWidth,
  int newHeight,
  int offsetX,
  int offsetY,
  Color fill,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<Image>)>()
external void ImageMipmaps(ffi.Pointer<Image> image);

@ffi.Native<
  ffi.Void Function(ffi.Pointer<Image>, ffi.Int, ffi.Int, ffi.Int, ffi.Int)
>()
external void ImageDither(
  ffi.Pointer<Image> image,
  int rBpp,
  int gBpp,
  int bBpp,
  int aBpp,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<Image>)>()
external void ImageFlipVertical(ffi.Pointer<Image> image);

@ffi.Native<ffi.Void Function(ffi.Pointer<Image>)>()
external void ImageFlipHorizontal(ffi.Pointer<Image> image);

@ffi.Native<ffi.Void Function(ffi.Pointer<Image>, ffi.Int)>()
external void ImageRotate(ffi.Pointer<Image> image, int degrees);

@ffi.Native<ffi.Void Function(ffi.Pointer<Image>)>()
external void ImageRotateCW(ffi.Pointer<Image> image);

@ffi.Native<ffi.Void Function(ffi.Pointer<Image>)>()
external void ImageRotateCCW(ffi.Pointer<Image> image);

@ffi.Native<ffi.Void Function(ffi.Pointer<Image>, Color)>()
external void ImageColorTint(ffi.Pointer<Image> image, Color color);

@ffi.Native<ffi.Void Function(ffi.Pointer<Image>)>()
external void ImageColorInvert(ffi.Pointer<Image> image);

@ffi.Native<ffi.Void Function(ffi.Pointer<Image>)>()
external void ImageColorGrayscale(ffi.Pointer<Image> image);

@ffi.Native<ffi.Void Function(ffi.Pointer<Image>, ffi.Float)>()
external void ImageColorContrast(ffi.Pointer<Image> image, double contrast);

@ffi.Native<ffi.Void Function(ffi.Pointer<Image>, ffi.Int)>()
external void ImageColorBrightness(ffi.Pointer<Image> image, int brightness);

@ffi.Native<ffi.Void Function(ffi.Pointer<Image>, Color, Color)>()
external void ImageColorReplace(
  ffi.Pointer<Image> image,
  Color color,
  Color replace,
);

@ffi.Native<ffi.Pointer<Color> Function(Image)>()
external ffi.Pointer<Color> LoadImageColors(Image image);

@ffi.Native<ffi.Pointer<Color> Function(Image, ffi.Int, ffi.Pointer<ffi.Int>)>()
external ffi.Pointer<Color> LoadImagePalette(
  Image image,
  int maxPaletteSize,
  ffi.Pointer<ffi.Int> colorCount,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<Color>)>()
external void UnloadImageColors(ffi.Pointer<Color> colors);

@ffi.Native<ffi.Void Function(ffi.Pointer<Color>)>()
external void UnloadImagePalette(ffi.Pointer<Color> colors);

@ffi.Native<Rectangle Function(Image, ffi.Float)>()
external Rectangle GetImageAlphaBorder(Image image, double threshold);

@ffi.Native<Color Function(Image, ffi.Int, ffi.Int)>()
external Color GetImageColor(Image image, int x, int y);

@ffi.Native<ffi.Void Function(ffi.Pointer<Image>, Color)>()
external void ImageClearBackground(ffi.Pointer<Image> dst, Color color);

@ffi.Native<ffi.Void Function(ffi.Pointer<Image>, ffi.Int, ffi.Int, Color)>()
external void ImageDrawPixel(
  ffi.Pointer<Image> dst,
  int posX,
  int posY,
  Color color,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<Image>, Vector2, Color)>()
external void ImageDrawPixelV(
  ffi.Pointer<Image> dst,
  Vector2 position,
  Color color,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<Image>,
    ffi.Int,
    ffi.Int,
    ffi.Int,
    ffi.Int,
    Color,
  )
>()
external void ImageDrawLine(
  ffi.Pointer<Image> dst,
  int startPosX,
  int startPosY,
  int endPosX,
  int endPosY,
  Color color,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<Image>, Vector2, Vector2, Color)>()
external void ImageDrawLineV(
  ffi.Pointer<Image> dst,
  Vector2 start,
  Vector2 end,
  Color color,
);

@ffi.Native<
  ffi.Void Function(ffi.Pointer<Image>, Vector2, Vector2, ffi.Int, Color)
>()
external void ImageDrawLineEx(
  ffi.Pointer<Image> dst,
  Vector2 start,
  Vector2 end,
  int thick,
  Color color,
);

@ffi.Native<
  ffi.Void Function(ffi.Pointer<Image>, ffi.Int, ffi.Int, ffi.Int, Color)
>()
external void ImageDrawCircle(
  ffi.Pointer<Image> dst,
  int centerX,
  int centerY,
  int radius,
  Color color,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<Image>, Vector2, ffi.Int, Color)>()
external void ImageDrawCircleV(
  ffi.Pointer<Image> dst,
  Vector2 center,
  int radius,
  Color color,
);

@ffi.Native<
  ffi.Void Function(ffi.Pointer<Image>, ffi.Int, ffi.Int, ffi.Int, Color)
>()
external void ImageDrawCircleLines(
  ffi.Pointer<Image> dst,
  int centerX,
  int centerY,
  int radius,
  Color color,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<Image>, Vector2, ffi.Int, Color)>()
external void ImageDrawCircleLinesV(
  ffi.Pointer<Image> dst,
  Vector2 center,
  int radius,
  Color color,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<Image>,
    ffi.Int,
    ffi.Int,
    ffi.Int,
    ffi.Int,
    Color,
  )
>()
external void ImageDrawRectangle(
  ffi.Pointer<Image> dst,
  int posX,
  int posY,
  int width,
  int height,
  Color color,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<Image>, Vector2, Vector2, Color)>()
external void ImageDrawRectangleV(
  ffi.Pointer<Image> dst,
  Vector2 position,
  Vector2 size,
  Color color,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<Image>, Rectangle, Color)>()
external void ImageDrawRectangleRec(
  ffi.Pointer<Image> dst,
  Rectangle rec,
  Color color,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<Image>, Rectangle, ffi.Int, Color)>()
external void ImageDrawRectangleLines(
  ffi.Pointer<Image> dst,
  Rectangle rec,
  int thick,
  Color color,
);

@ffi.Native<
  ffi.Void Function(ffi.Pointer<Image>, Vector2, Vector2, Vector2, Color)
>()
external void ImageDrawTriangle(
  ffi.Pointer<Image> dst,
  Vector2 v1,
  Vector2 v2,
  Vector2 v3,
  Color color,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<Image>,
    Vector2,
    Vector2,
    Vector2,
    Color,
    Color,
    Color,
  )
>()
external void ImageDrawTriangleEx(
  ffi.Pointer<Image> dst,
  Vector2 v1,
  Vector2 v2,
  Vector2 v3,
  Color c1,
  Color c2,
  Color c3,
);

@ffi.Native<
  ffi.Void Function(ffi.Pointer<Image>, Vector2, Vector2, Vector2, Color)
>()
external void ImageDrawTriangleLines(
  ffi.Pointer<Image> dst,
  Vector2 v1,
  Vector2 v2,
  Vector2 v3,
  Color color,
);

@ffi.Native<
  ffi.Void Function(ffi.Pointer<Image>, ffi.Pointer<Vector2>, ffi.Int, Color)
>()
external void ImageDrawTriangleFan(
  ffi.Pointer<Image> dst,
  ffi.Pointer<Vector2> points,
  int pointCount,
  Color color,
);

@ffi.Native<
  ffi.Void Function(ffi.Pointer<Image>, ffi.Pointer<Vector2>, ffi.Int, Color)
>()
external void ImageDrawTriangleStrip(
  ffi.Pointer<Image> dst,
  ffi.Pointer<Vector2> points,
  int pointCount,
  Color color,
);

@ffi.Native<
  ffi.Void Function(ffi.Pointer<Image>, Image, Rectangle, Rectangle, Color)
>()
external void ImageDraw(
  ffi.Pointer<Image> dst,
  Image src,
  Rectangle srcRec,
  Rectangle dstRec,
  Color tint,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<Image>,
    ffi.Pointer<ffi.Char>,
    ffi.Int,
    ffi.Int,
    ffi.Int,
    Color,
  )
>()
external void ImageDrawText(
  ffi.Pointer<Image> dst,
  ffi.Pointer<ffi.Char> text,
  int posX,
  int posY,
  int fontSize,
  Color color,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<Image>,
    Font,
    ffi.Pointer<ffi.Char>,
    Vector2,
    ffi.Float,
    ffi.Float,
    Color,
  )
>()
external void ImageDrawTextEx(
  ffi.Pointer<Image> dst,
  Font font,
  ffi.Pointer<ffi.Char> text,
  Vector2 position,
  double fontSize,
  double spacing,
  Color tint,
);

@ffi.Native<Texture2D Function(ffi.Pointer<ffi.Char>)>()
external Texture2D LoadTexture(ffi.Pointer<ffi.Char> fileName);

@ffi.Native<Texture2D Function(Image)>()
external Texture2D LoadTextureFromImage(Image image);

@ffi.Native<TextureCubemap Function(Image, ffi.Int)>()
external TextureCubemap LoadTextureCubemap(Image image, int layout);

@ffi.Native<RenderTexture2D Function(ffi.Int, ffi.Int)>()
external RenderTexture2D LoadRenderTexture(int width, int height);

@ffi.Native<ffi.Bool Function(Texture2D)>()
external bool IsTextureValid(Texture2D texture);

@ffi.Native<ffi.Void Function(Texture2D)>()
external void UnloadTexture(Texture2D texture);

@ffi.Native<ffi.Bool Function(RenderTexture2D)>()
external bool IsRenderTextureValid(RenderTexture2D target);

@ffi.Native<ffi.Void Function(RenderTexture2D)>()
external void UnloadRenderTexture(RenderTexture2D target);

@ffi.Native<ffi.Void Function(Texture2D, ffi.Pointer<ffi.Void>)>()
external void UpdateTexture(Texture2D texture, ffi.Pointer<ffi.Void> pixels);

@ffi.Native<ffi.Void Function(Texture2D, Rectangle, ffi.Pointer<ffi.Void>)>()
external void UpdateTextureRec(
  Texture2D texture,
  Rectangle rec,
  ffi.Pointer<ffi.Void> pixels,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<Texture2D>)>()
external void GenTextureMipmaps(ffi.Pointer<Texture2D> texture);

@ffi.Native<ffi.Void Function(Texture2D, ffi.Int)>()
external void SetTextureFilter(Texture2D texture, int filter);

@ffi.Native<ffi.Void Function(Texture2D, ffi.Int)>()
external void SetTextureWrap(Texture2D texture, int wrap);

@ffi.Native<ffi.Void Function(Texture2D, ffi.Int, ffi.Int, Color)>()
external void DrawTexture(Texture2D texture, int posX, int posY, Color tint);

@ffi.Native<ffi.Void Function(Texture2D, Vector2, Color)>()
external void DrawTextureV(Texture2D texture, Vector2 position, Color tint);

@ffi.Native<
  ffi.Void Function(Texture2D, Vector2, ffi.Float, ffi.Float, Color)
>()
external void DrawTextureEx(
  Texture2D texture,
  Vector2 position,
  double rotation,
  double scale,
  Color tint,
);

@ffi.Native<ffi.Void Function(Texture2D, Rectangle, Vector2, Color)>()
external void DrawTextureRec(
  Texture2D texture,
  Rectangle source,
  Vector2 position,
  Color tint,
);

@ffi.Native<
  ffi.Void Function(Texture2D, Rectangle, Rectangle, Vector2, ffi.Float, Color)
>()
external void DrawTexturePro(
  Texture2D texture,
  Rectangle source,
  Rectangle dest,
  Vector2 origin,
  double rotation,
  Color tint,
);

@ffi.Native<
  ffi.Void Function(Texture2D, NPatchInfo, Rectangle, Vector2, ffi.Float, Color)
>()
external void DrawTextureNPatch(
  Texture2D texture,
  NPatchInfo nPatchInfo,
  Rectangle dest,
  Vector2 origin,
  double rotation,
  Color tint,
);

@ffi.Native<ffi.Bool Function(Color, Color)>()
external bool ColorIsEqual(Color col1, Color col2);

@ffi.Native<Color Function(Color, ffi.Float)>()
external Color Fade(Color color, double alpha);

@ffi.Native<ffi.Int Function(Color)>()
external int ColorToInt(Color color);

@ffi.Native<Vector4 Function(Color)>()
external Vector4 ColorNormalize(Color color);

@ffi.Native<Color Function(Vector4)>()
external Color ColorFromNormalized(Vector4 normalized);

@ffi.Native<Vector3 Function(Color)>()
external Vector3 ColorToHSV(Color color);

@ffi.Native<Color Function(ffi.Float, ffi.Float, ffi.Float)>()
external Color ColorFromHSV(double hue, double saturation, double value);

@ffi.Native<Color Function(Color, Color)>()
external Color ColorTint(Color color, Color tint);

@ffi.Native<Color Function(Color, ffi.Float)>()
external Color ColorBrightness(Color color, double factor);

@ffi.Native<Color Function(Color, ffi.Float)>()
external Color ColorContrast(Color color, double contrast);

@ffi.Native<Color Function(Color, ffi.Float)>()
external Color ColorAlpha(Color color, double alpha);

@ffi.Native<Color Function(Color, Color, Color)>()
external Color ColorAlphaBlend(Color dst, Color src, Color tint);

@ffi.Native<Color Function(Color, Color, ffi.Float)>()
external Color ColorLerp(Color color1, Color color2, double factor);

@ffi.Native<Color Function(ffi.UnsignedInt)>()
external Color GetColor(int hexValue);

@ffi.Native<Color Function(ffi.Pointer<ffi.Void>, ffi.Int)>()
external Color GetPixelColor(ffi.Pointer<ffi.Void> srcPtr, int format);

@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Void>, Color, ffi.Int)>()
external void SetPixelColor(
  ffi.Pointer<ffi.Void> dstPtr,
  Color color,
  int format,
);

@ffi.Native<ffi.Int Function(ffi.Int, ffi.Int, ffi.Int)>()
external int GetPixelDataSize(int width, int height, int format);

@ffi.Native<Font Function()>()
external Font GetFontDefault();

@ffi.Native<Font Function(ffi.Pointer<ffi.Char>)>()
external Font LoadFont(ffi.Pointer<ffi.Char> fileName);

@ffi.Native<
  Font Function(ffi.Pointer<ffi.Char>, ffi.Int, ffi.Pointer<ffi.Int>, ffi.Int)
>()
external Font LoadFontEx(
  ffi.Pointer<ffi.Char> fileName,
  int fontSize,
  ffi.Pointer<ffi.Int> codepoints,
  int codepointCount,
);

@ffi.Native<Font Function(Image, Color, ffi.Int)>()
external Font LoadFontFromImage(Image image, Color key, int firstChar);

@ffi.Native<
  Font Function(
    ffi.Pointer<ffi.Char>,
    ffi.Pointer<ffi.UnsignedChar>,
    ffi.Int,
    ffi.Int,
    ffi.Pointer<ffi.Int>,
    ffi.Int,
  )
>()
external Font LoadFontFromMemory(
  ffi.Pointer<ffi.Char> fileType,
  ffi.Pointer<ffi.UnsignedChar> fileData,
  int dataSize,
  int fontSize,
  ffi.Pointer<ffi.Int> codepoints,
  int codepointCount,
);

@ffi.Native<ffi.Bool Function(Font)>()
external bool IsFontValid(Font font);

@ffi.Native<
  ffi.Pointer<GlyphInfo> Function(
    ffi.Pointer<ffi.UnsignedChar>,
    ffi.Int,
    ffi.Int,
    ffi.Pointer<ffi.Int>,
    ffi.Int,
    ffi.Int,
    ffi.Pointer<ffi.Int>,
  )
>()
external ffi.Pointer<GlyphInfo> LoadFontData(
  ffi.Pointer<ffi.UnsignedChar> fileData,
  int dataSize,
  int fontSize,
  ffi.Pointer<ffi.Int> codepoints,
  int codepointCount,
  int type,
  ffi.Pointer<ffi.Int> glyphCount,
);

@ffi.Native<
  Image Function(
    ffi.Pointer<GlyphInfo>,
    ffi.Pointer<ffi.Pointer<Rectangle>>,
    ffi.Int,
    ffi.Int,
    ffi.Int,
    ffi.Int,
  )
>()
external Image GenImageFontAtlas(
  ffi.Pointer<GlyphInfo> glyphs,
  ffi.Pointer<ffi.Pointer<Rectangle>> glyphRecs,
  int glyphCount,
  int fontSize,
  int padding,
  int packMethod,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<GlyphInfo>, ffi.Int)>()
external void UnloadFontData(ffi.Pointer<GlyphInfo> glyphs, int glyphCount);

@ffi.Native<ffi.Void Function(Font)>()
external void UnloadFont(Font font);

@ffi.Native<ffi.Bool Function(Font, ffi.Pointer<ffi.Char>)>()
external bool ExportFontAsCode(Font font, ffi.Pointer<ffi.Char> fileName);

@ffi.Native<ffi.Void Function(ffi.Int, ffi.Int)>()
external void DrawFPS(int posX, int posY);

@ffi.Native<
  ffi.Void Function(ffi.Pointer<ffi.Char>, ffi.Int, ffi.Int, ffi.Int, Color)
>()
external void DrawText(
  ffi.Pointer<ffi.Char> text,
  int posX,
  int posY,
  int fontSize,
  Color color,
);

@ffi.Native<
  ffi.Void Function(
    Font,
    ffi.Pointer<ffi.Char>,
    Vector2,
    ffi.Float,
    ffi.Float,
    Color,
  )
>()
external void DrawTextEx(
  Font font,
  ffi.Pointer<ffi.Char> text,
  Vector2 position,
  double fontSize,
  double spacing,
  Color tint,
);

@ffi.Native<
  ffi.Void Function(
    Font,
    ffi.Pointer<ffi.Char>,
    Vector2,
    Vector2,
    ffi.Float,
    ffi.Float,
    ffi.Float,
    Color,
  )
>()
external void DrawTextPro(
  Font font,
  ffi.Pointer<ffi.Char> text,
  Vector2 position,
  Vector2 origin,
  double rotation,
  double fontSize,
  double spacing,
  Color tint,
);

@ffi.Native<ffi.Void Function(Font, ffi.Int, Vector2, ffi.Float, Color)>()
external void DrawTextCodepoint(
  Font font,
  int codepoint,
  Vector2 position,
  double fontSize,
  Color tint,
);

@ffi.Native<
  ffi.Void Function(
    Font,
    ffi.Pointer<ffi.Int>,
    ffi.Int,
    Vector2,
    ffi.Float,
    ffi.Float,
    Color,
  )
>()
external void DrawTextCodepoints(
  Font font,
  ffi.Pointer<ffi.Int> codepoints,
  int codepointCount,
  Vector2 position,
  double fontSize,
  double spacing,
  Color tint,
);

@ffi.Native<ffi.Void Function(ffi.Int)>()
external void SetTextLineSpacing(int spacing);

@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Int)>()
external int MeasureText(ffi.Pointer<ffi.Char> text, int fontSize);

@ffi.Native<
  Vector2 Function(Font, ffi.Pointer<ffi.Char>, ffi.Float, ffi.Float)
>()
external Vector2 MeasureTextEx(
  Font font,
  ffi.Pointer<ffi.Char> text,
  double fontSize,
  double spacing,
);

@ffi.Native<ffi.Int Function(Font, ffi.Int)>()
external int GetGlyphIndex(Font font, int codepoint);

@ffi.Native<GlyphInfo Function(Font, ffi.Int)>()
external GlyphInfo GetGlyphInfo(Font font, int codepoint);

@ffi.Native<Rectangle Function(Font, ffi.Int)>()
external Rectangle GetGlyphAtlasRec(Font font, int codepoint);

@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Int>, ffi.Int)>()
external ffi.Pointer<ffi.Char> LoadUTF8(
  ffi.Pointer<ffi.Int> codepoints,
  int length,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Char>)>()
external void UnloadUTF8(ffi.Pointer<ffi.Char> text);

@ffi.Native<
  ffi.Pointer<ffi.Int> Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Int>)
>()
external ffi.Pointer<ffi.Int> LoadCodepoints(
  ffi.Pointer<ffi.Char> text,
  ffi.Pointer<ffi.Int> count,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Int>)>()
external void UnloadCodepoints(ffi.Pointer<ffi.Int> codepoints);

@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Char>)>()
external int GetCodepointCount(ffi.Pointer<ffi.Char> text);

@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Int>)>()
external int GetCodepoint(
  ffi.Pointer<ffi.Char> text,
  ffi.Pointer<ffi.Int> codepointSize,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Int>)>()
external int GetCodepointNext(
  ffi.Pointer<ffi.Char> text,
  ffi.Pointer<ffi.Int> codepointSize,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Int>)>()
external int GetCodepointPrevious(
  ffi.Pointer<ffi.Char> text,
  ffi.Pointer<ffi.Int> codepointSize,
);

@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Int, ffi.Pointer<ffi.Int>)>()
external ffi.Pointer<ffi.Char> CodepointToUTF8(
  int codepoint,
  ffi.Pointer<ffi.Int> utf8Size,
);

@ffi.Native<
  ffi.Pointer<ffi.Pointer<ffi.Char>> Function(
    ffi.Pointer<ffi.Char>,
    ffi.Pointer<ffi.Int>,
  )
>()
external ffi.Pointer<ffi.Pointer<ffi.Char>> LoadTextLines(
  ffi.Pointer<ffi.Char> text,
  ffi.Pointer<ffi.Int> count,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>()
external void UnloadTextLines(
  ffi.Pointer<ffi.Pointer<ffi.Char>> text,
  int lineCount,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>()
external int TextCopy(ffi.Pointer<ffi.Char> dst, ffi.Pointer<ffi.Char> src);

@ffi.Native<ffi.Bool Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>()
external bool TextIsEqual(
  ffi.Pointer<ffi.Char> text1,
  ffi.Pointer<ffi.Char> text2,
);

@ffi.Native<ffi.UnsignedInt Function(ffi.Pointer<ffi.Char>)>()
external int TextLength(ffi.Pointer<ffi.Char> text);

@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>()
external ffi.Pointer<ffi.Char> TextFormat(ffi.Pointer<ffi.Char> text);

@ffi.Native<
  ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, ffi.Int, ffi.Int)
>()
external ffi.Pointer<ffi.Char> TextSubtext(
  ffi.Pointer<ffi.Char> text,
  int position,
  int length,
);

@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>()
external ffi.Pointer<ffi.Char> TextRemoveSpaces(ffi.Pointer<ffi.Char> text);

@ffi.Native<
  ffi.Pointer<ffi.Char> Function(
    ffi.Pointer<ffi.Char>,
    ffi.Pointer<ffi.Char>,
    ffi.Pointer<ffi.Char>,
  )
>()
external ffi.Pointer<ffi.Char> GetTextBetween(
  ffi.Pointer<ffi.Char> text,
  ffi.Pointer<ffi.Char> begin,
  ffi.Pointer<ffi.Char> end,
);

@ffi.Native<
  ffi.Pointer<ffi.Char> Function(
    ffi.Pointer<ffi.Char>,
    ffi.Pointer<ffi.Char>,
    ffi.Pointer<ffi.Char>,
  )
>()
external ffi.Pointer<ffi.Char> TextReplace(
  ffi.Pointer<ffi.Char> text,
  ffi.Pointer<ffi.Char> search,
  ffi.Pointer<ffi.Char> replacement,
);

@ffi.Native<
  ffi.Pointer<ffi.Char> Function(
    ffi.Pointer<ffi.Char>,
    ffi.Pointer<ffi.Char>,
    ffi.Pointer<ffi.Char>,
    ffi.Pointer<ffi.Char>,
  )
>()
external ffi.Pointer<ffi.Char> TextReplaceBetween(
  ffi.Pointer<ffi.Char> text,
  ffi.Pointer<ffi.Char> begin,
  ffi.Pointer<ffi.Char> end,
  ffi.Pointer<ffi.Char> replacement,
);

@ffi.Native<
  ffi.Pointer<ffi.Char> Function(
    ffi.Pointer<ffi.Char>,
    ffi.Pointer<ffi.Char>,
    ffi.Int,
  )
>()
external ffi.Pointer<ffi.Char> TextInsert(
  ffi.Pointer<ffi.Char> text,
  ffi.Pointer<ffi.Char> insert,
  int position,
);

@ffi.Native<
  ffi.Pointer<ffi.Char> Function(
    ffi.Pointer<ffi.Pointer<ffi.Char>>,
    ffi.Int,
    ffi.Pointer<ffi.Char>,
  )
>()
external ffi.Pointer<ffi.Char> TextJoin(
  ffi.Pointer<ffi.Pointer<ffi.Char>> textList,
  int count,
  ffi.Pointer<ffi.Char> delimiter,
);

@ffi.Native<
  ffi.Pointer<ffi.Pointer<ffi.Char>> Function(
    ffi.Pointer<ffi.Char>,
    ffi.Char,
    ffi.Pointer<ffi.Int>,
  )
>()
external ffi.Pointer<ffi.Pointer<ffi.Char>> TextSplit(
  ffi.Pointer<ffi.Char> text,
  int delimiter,
  ffi.Pointer<ffi.Int> count,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<ffi.Char>,
    ffi.Pointer<ffi.Char>,
    ffi.Pointer<ffi.Int>,
  )
>()
external void TextAppend(
  ffi.Pointer<ffi.Char> text,
  ffi.Pointer<ffi.Char> append,
  ffi.Pointer<ffi.Int> position,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>()
external int TextFindIndex(
  ffi.Pointer<ffi.Char> text,
  ffi.Pointer<ffi.Char> search,
);

@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>()
external ffi.Pointer<ffi.Char> TextToUpper(ffi.Pointer<ffi.Char> text);

@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>()
external ffi.Pointer<ffi.Char> TextToLower(ffi.Pointer<ffi.Char> text);

@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>()
external ffi.Pointer<ffi.Char> TextToPascal(ffi.Pointer<ffi.Char> text);

@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>()
external ffi.Pointer<ffi.Char> TextToSnake(ffi.Pointer<ffi.Char> text);

@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>()
external ffi.Pointer<ffi.Char> TextToCamel(ffi.Pointer<ffi.Char> text);

@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Char>)>()
external int TextToInteger(ffi.Pointer<ffi.Char> text);

@ffi.Native<ffi.Float Function(ffi.Pointer<ffi.Char>)>()
external double TextToFloat(ffi.Pointer<ffi.Char> text);

@ffi.Native<ffi.Void Function(Vector3, Vector3, Color)>()
external void DrawLine3D(Vector3 startPos, Vector3 endPos, Color color);

@ffi.Native<ffi.Void Function(Vector3, Color)>()
external void DrawPoint3D(Vector3 position, Color color);

@ffi.Native<ffi.Void Function(Vector3, ffi.Float, Vector3, ffi.Float, Color)>()
external void DrawCircle3D(
  Vector3 center,
  double radius,
  Vector3 rotationAxis,
  double rotationAngle,
  Color color,
);

@ffi.Native<ffi.Void Function(Vector3, Vector3, Vector3, Color)>()
external void DrawTriangle3D(Vector3 v1, Vector3 v2, Vector3 v3, Color color);

@ffi.Native<ffi.Void Function(ffi.Pointer<Vector3>, ffi.Int, Color)>()
external void DrawTriangleStrip3D(
  ffi.Pointer<Vector3> points,
  int pointCount,
  Color color,
);

@ffi.Native<
  ffi.Void Function(Vector3, ffi.Float, ffi.Float, ffi.Float, Color)
>()
external void DrawCube(
  Vector3 position,
  double width,
  double height,
  double length,
  Color color,
);

@ffi.Native<ffi.Void Function(Vector3, Vector3, Color)>()
external void DrawCubeV(Vector3 position, Vector3 size, Color color);

@ffi.Native<
  ffi.Void Function(Vector3, ffi.Float, ffi.Float, ffi.Float, Color)
>()
external void DrawCubeWires(
  Vector3 position,
  double width,
  double height,
  double length,
  Color color,
);

@ffi.Native<ffi.Void Function(Vector3, Vector3, Color)>()
external void DrawCubeWiresV(Vector3 position, Vector3 size, Color color);

@ffi.Native<ffi.Void Function(Vector3, ffi.Float, Color)>()
external void DrawSphere(Vector3 centerPos, double radius, Color color);

@ffi.Native<ffi.Void Function(Vector3, ffi.Float, ffi.Int, ffi.Int, Color)>()
external void DrawSphereEx(
  Vector3 centerPos,
  double radius,
  int rings,
  int slices,
  Color color,
);

@ffi.Native<ffi.Void Function(Vector3, ffi.Float, ffi.Int, ffi.Int, Color)>()
external void DrawSphereWires(
  Vector3 centerPos,
  double radius,
  int rings,
  int slices,
  Color color,
);

@ffi.Native<
  ffi.Void Function(Vector3, ffi.Float, ffi.Float, ffi.Float, ffi.Int, Color)
>()
external void DrawCylinder(
  Vector3 position,
  double radiusTop,
  double radiusBottom,
  double height,
  int slices,
  Color color,
);

@ffi.Native<
  ffi.Void Function(Vector3, Vector3, ffi.Float, ffi.Float, ffi.Int, Color)
>()
external void DrawCylinderEx(
  Vector3 startPos,
  Vector3 endPos,
  double startRadius,
  double endRadius,
  int sides,
  Color color,
);

@ffi.Native<
  ffi.Void Function(Vector3, ffi.Float, ffi.Float, ffi.Float, ffi.Int, Color)
>()
external void DrawCylinderWires(
  Vector3 position,
  double radiusTop,
  double radiusBottom,
  double height,
  int slices,
  Color color,
);

@ffi.Native<
  ffi.Void Function(Vector3, Vector3, ffi.Float, ffi.Float, ffi.Int, Color)
>()
external void DrawCylinderWiresEx(
  Vector3 startPos,
  Vector3 endPos,
  double startRadius,
  double endRadius,
  int sides,
  Color color,
);

@ffi.Native<
  ffi.Void Function(Vector3, Vector3, ffi.Float, ffi.Int, ffi.Int, Color)
>()
external void DrawCapsule(
  Vector3 startPos,
  Vector3 endPos,
  double radius,
  int slices,
  int rings,
  Color color,
);

@ffi.Native<
  ffi.Void Function(Vector3, Vector3, ffi.Float, ffi.Int, ffi.Int, Color)
>()
external void DrawCapsuleWires(
  Vector3 startPos,
  Vector3 endPos,
  double radius,
  int slices,
  int rings,
  Color color,
);

@ffi.Native<ffi.Void Function(Vector3, Vector2, Color)>()
external void DrawPlane(Vector3 centerPos, Vector2 size, Color color);

@ffi.Native<ffi.Void Function(Ray, Color)>()
external void DrawRay(Ray ray, Color color);

@ffi.Native<ffi.Void Function(ffi.Int, ffi.Float)>()
external void DrawGrid(int slices, double spacing);

@ffi.Native<Model Function(ffi.Pointer<ffi.Char>)>()
external Model LoadModel(ffi.Pointer<ffi.Char> fileName);

@ffi.Native<Model Function(Mesh)>()
external Model LoadModelFromMesh(Mesh mesh);

@ffi.Native<ffi.Bool Function(Model)>()
external bool IsModelValid(Model model);

@ffi.Native<ffi.Void Function(Model)>()
external void UnloadModel(Model model);

@ffi.Native<BoundingBox Function(Model)>()
external BoundingBox GetModelBoundingBox(Model model);

@ffi.Native<ffi.Void Function(Model, Vector3, ffi.Float, Color)>()
external void DrawModel(
  Model model,
  Vector3 position,
  double scale,
  Color tint,
);

@ffi.Native<
  ffi.Void Function(Model, Vector3, Vector3, ffi.Float, Vector3, Color)
>()
external void DrawModelEx(
  Model model,
  Vector3 position,
  Vector3 rotationAxis,
  double rotationAngle,
  Vector3 scale,
  Color tint,
);

@ffi.Native<ffi.Void Function(Model, Vector3, ffi.Float, Color)>()
external void DrawModelWires(
  Model model,
  Vector3 position,
  double scale,
  Color tint,
);

@ffi.Native<
  ffi.Void Function(Model, Vector3, Vector3, ffi.Float, Vector3, Color)
>()
external void DrawModelWiresEx(
  Model model,
  Vector3 position,
  Vector3 rotationAxis,
  double rotationAngle,
  Vector3 scale,
  Color tint,
);

@ffi.Native<ffi.Void Function(Model, Vector3, ffi.Float, Color)>()
external void DrawModelPoints(
  Model model,
  Vector3 position,
  double scale,
  Color tint,
);

@ffi.Native<
  ffi.Void Function(Model, Vector3, Vector3, ffi.Float, Vector3, Color)
>()
external void DrawModelPointsEx(
  Model model,
  Vector3 position,
  Vector3 rotationAxis,
  double rotationAngle,
  Vector3 scale,
  Color tint,
);

@ffi.Native<ffi.Void Function(BoundingBox, Color)>()
external void DrawBoundingBox(BoundingBox box, Color color);

@ffi.Native<ffi.Void Function(Camera, Texture2D, Vector3, ffi.Float, Color)>()
external void DrawBillboard(
  Camera camera,
  Texture2D texture,
  Vector3 position,
  double scale,
  Color tint,
);

@ffi.Native<
  ffi.Void Function(Camera, Texture2D, Rectangle, Vector3, Vector2, Color)
>()
external void DrawBillboardRec(
  Camera camera,
  Texture2D texture,
  Rectangle source,
  Vector3 position,
  Vector2 size,
  Color tint,
);

@ffi.Native<
  ffi.Void Function(
    Camera,
    Texture2D,
    Rectangle,
    Vector3,
    Vector3,
    Vector2,
    Vector2,
    ffi.Float,
    Color,
  )
>()
external void DrawBillboardPro(
  Camera camera,
  Texture2D texture,
  Rectangle source,
  Vector3 position,
  Vector3 up,
  Vector2 size,
  Vector2 origin,
  double rotation,
  Color tint,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<Mesh>, ffi.Bool)>()
external void UploadMesh(ffi.Pointer<Mesh> mesh, bool dynamic);

@ffi.Native<
  ffi.Void Function(Mesh, ffi.Int, ffi.Pointer<ffi.Void>, ffi.Int, ffi.Int)
>()
external void UpdateMeshBuffer(
  Mesh mesh,
  int index,
  ffi.Pointer<ffi.Void> data,
  int dataSize,
  int offset,
);

@ffi.Native<ffi.Void Function(Mesh)>()
external void UnloadMesh(Mesh mesh);

@ffi.Native<ffi.Void Function(Mesh, Material, Matrix)>()
external void DrawMesh(Mesh mesh, Material material, Matrix transform);

@ffi.Native<ffi.Void Function(Mesh, Material, ffi.Pointer<Matrix>, ffi.Int)>()
external void DrawMeshInstanced(
  Mesh mesh,
  Material material,
  ffi.Pointer<Matrix> transforms,
  int instances,
);

@ffi.Native<BoundingBox Function(Mesh)>()
external BoundingBox GetMeshBoundingBox(Mesh mesh);

@ffi.Native<ffi.Void Function(ffi.Pointer<Mesh>)>()
external void GenMeshTangents(ffi.Pointer<Mesh> mesh);

@ffi.Native<ffi.Bool Function(Mesh, ffi.Pointer<ffi.Char>)>()
external bool ExportMesh(Mesh mesh, ffi.Pointer<ffi.Char> fileName);

@ffi.Native<ffi.Bool Function(Mesh, ffi.Pointer<ffi.Char>)>()
external bool ExportMeshAsCode(Mesh mesh, ffi.Pointer<ffi.Char> fileName);

@ffi.Native<Mesh Function(ffi.Int, ffi.Float)>()
external Mesh GenMeshPoly(int sides, double radius);

@ffi.Native<Mesh Function(ffi.Float, ffi.Float, ffi.Int, ffi.Int)>()
external Mesh GenMeshPlane(double width, double length, int resX, int resZ);

@ffi.Native<Mesh Function(ffi.Float, ffi.Float, ffi.Float)>()
external Mesh GenMeshCube(double width, double height, double length);

@ffi.Native<Mesh Function(ffi.Float, ffi.Int, ffi.Int)>()
external Mesh GenMeshSphere(double radius, int rings, int slices);

@ffi.Native<Mesh Function(ffi.Float, ffi.Int, ffi.Int)>()
external Mesh GenMeshHemiSphere(double radius, int rings, int slices);

@ffi.Native<Mesh Function(ffi.Float, ffi.Float, ffi.Int)>()
external Mesh GenMeshCylinder(double radius, double height, int slices);

@ffi.Native<Mesh Function(ffi.Float, ffi.Float, ffi.Int)>()
external Mesh GenMeshCone(double radius, double height, int slices);

@ffi.Native<Mesh Function(ffi.Float, ffi.Float, ffi.Int, ffi.Int)>()
external Mesh GenMeshTorus(double radius, double size, int radSeg, int sides);

@ffi.Native<Mesh Function(ffi.Float, ffi.Float, ffi.Int, ffi.Int)>()
external Mesh GenMeshKnot(double radius, double size, int radSeg, int sides);

@ffi.Native<Mesh Function(Image, Vector3)>()
external Mesh GenMeshHeightmap(Image heightmap, Vector3 size);

@ffi.Native<Mesh Function(Image, Vector3)>()
external Mesh GenMeshCubicmap(Image cubicmap, Vector3 cubeSize);

@ffi.Native<
  ffi.Pointer<Material> Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Int>)
>()
external ffi.Pointer<Material> LoadMaterials(
  ffi.Pointer<ffi.Char> fileName,
  ffi.Pointer<ffi.Int> materialCount,
);

@ffi.Native<Material Function()>()
external Material LoadMaterialDefault();

@ffi.Native<ffi.Bool Function(Material)>()
external bool IsMaterialValid(Material material);

@ffi.Native<ffi.Void Function(Material)>()
external void UnloadMaterial(Material material);

@ffi.Native<ffi.Void Function(ffi.Pointer<Material>, ffi.Int, Texture2D)>()
external void SetMaterialTexture(
  ffi.Pointer<Material> material,
  int mapType,
  Texture2D texture,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<Model>, ffi.Int, ffi.Int)>()
external void SetModelMeshMaterial(
  ffi.Pointer<Model> model,
  int meshId,
  int materialId,
);

@ffi.Native<
  ffi.Pointer<ModelAnimation> Function(
    ffi.Pointer<ffi.Char>,
    ffi.Pointer<ffi.Int>,
  )
>()
external ffi.Pointer<ModelAnimation> LoadModelAnimations(
  ffi.Pointer<ffi.Char> fileName,
  ffi.Pointer<ffi.Int> animCount,
);

@ffi.Native<ffi.Void Function(Model, ModelAnimation, ffi.Int)>()
external void UpdateModelAnimation(Model model, ModelAnimation anim, int frame);

@ffi.Native<ffi.Void Function(Model, ModelAnimation, ffi.Int)>()
external void UpdateModelAnimationBones(
  Model model,
  ModelAnimation anim,
  int frame,
);

@ffi.Native<ffi.Void Function(ModelAnimation)>()
external void UnloadModelAnimation(ModelAnimation anim);

@ffi.Native<ffi.Void Function(ffi.Pointer<ModelAnimation>, ffi.Int)>()
external void UnloadModelAnimations(
  ffi.Pointer<ModelAnimation> animations,
  int animCount,
);

@ffi.Native<ffi.Bool Function(Model, ModelAnimation)>()
external bool IsModelAnimationValid(Model model, ModelAnimation anim);

@ffi.Native<ffi.Bool Function(Vector3, ffi.Float, Vector3, ffi.Float)>()
external bool CheckCollisionSpheres(
  Vector3 center1,
  double radius1,
  Vector3 center2,
  double radius2,
);

@ffi.Native<ffi.Bool Function(BoundingBox, BoundingBox)>()
external bool CheckCollisionBoxes(BoundingBox box1, BoundingBox box2);

@ffi.Native<ffi.Bool Function(BoundingBox, Vector3, ffi.Float)>()
external bool CheckCollisionBoxSphere(
  BoundingBox box,
  Vector3 center,
  double radius,
);

@ffi.Native<RayCollision Function(Ray, Vector3, ffi.Float)>()
external RayCollision GetRayCollisionSphere(
  Ray ray,
  Vector3 center,
  double radius,
);

@ffi.Native<RayCollision Function(Ray, BoundingBox)>()
external RayCollision GetRayCollisionBox(Ray ray, BoundingBox box);

@ffi.Native<RayCollision Function(Ray, Mesh, Matrix)>()
external RayCollision GetRayCollisionMesh(Ray ray, Mesh mesh, Matrix transform);

@ffi.Native<RayCollision Function(Ray, Vector3, Vector3, Vector3)>()
external RayCollision GetRayCollisionTriangle(
  Ray ray,
  Vector3 p1,
  Vector3 p2,
  Vector3 p3,
);

@ffi.Native<RayCollision Function(Ray, Vector3, Vector3, Vector3, Vector3)>()
external RayCollision GetRayCollisionQuad(
  Ray ray,
  Vector3 p1,
  Vector3 p2,
  Vector3 p3,
  Vector3 p4,
);

@ffi.Native<ffi.Void Function()>()
external void InitAudioDevice();

@ffi.Native<ffi.Void Function()>()
external void CloseAudioDevice();

@ffi.Native<ffi.Bool Function()>()
external bool IsAudioDeviceReady();

@ffi.Native<ffi.Void Function(ffi.Float)>()
external void SetMasterVolume(double volume);

@ffi.Native<ffi.Float Function()>()
external double GetMasterVolume();

@ffi.Native<Wave Function(ffi.Pointer<ffi.Char>)>()
external Wave LoadWave(ffi.Pointer<ffi.Char> fileName);

@ffi.Native<
  Wave Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.UnsignedChar>, ffi.Int)
>()
external Wave LoadWaveFromMemory(
  ffi.Pointer<ffi.Char> fileType,
  ffi.Pointer<ffi.UnsignedChar> fileData,
  int dataSize,
);

@ffi.Native<ffi.Bool Function(Wave)>()
external bool IsWaveValid(Wave wave);

@ffi.Native<Sound Function(ffi.Pointer<ffi.Char>)>()
external Sound LoadSound(ffi.Pointer<ffi.Char> fileName);

@ffi.Native<Sound Function(Wave)>()
external Sound LoadSoundFromWave(Wave wave);

@ffi.Native<Sound Function(Sound)>()
external Sound LoadSoundAlias(Sound source);

@ffi.Native<ffi.Bool Function(Sound)>()
external bool IsSoundValid(Sound sound);

@ffi.Native<ffi.Void Function(Sound, ffi.Pointer<ffi.Void>, ffi.Int)>()
external void UpdateSound(
  Sound sound,
  ffi.Pointer<ffi.Void> data,
  int sampleCount,
);

@ffi.Native<ffi.Void Function(Wave)>()
external void UnloadWave(Wave wave);

@ffi.Native<ffi.Void Function(Sound)>()
external void UnloadSound(Sound sound);

@ffi.Native<ffi.Void Function(Sound)>()
external void UnloadSoundAlias(Sound alias);

@ffi.Native<ffi.Bool Function(Wave, ffi.Pointer<ffi.Char>)>()
external bool ExportWave(Wave wave, ffi.Pointer<ffi.Char> fileName);

@ffi.Native<ffi.Bool Function(Wave, ffi.Pointer<ffi.Char>)>()
external bool ExportWaveAsCode(Wave wave, ffi.Pointer<ffi.Char> fileName);

@ffi.Native<ffi.Void Function(Sound)>()
external void PlaySound(Sound sound);

@ffi.Native<ffi.Void Function(Sound)>()
external void StopSound(Sound sound);

@ffi.Native<ffi.Void Function(Sound)>()
external void PauseSound(Sound sound);

@ffi.Native<ffi.Void Function(Sound)>()
external void ResumeSound(Sound sound);

@ffi.Native<ffi.Bool Function(Sound)>()
external bool IsSoundPlaying(Sound sound);

@ffi.Native<ffi.Void Function(Sound, ffi.Float)>()
external void SetSoundVolume(Sound sound, double volume);

@ffi.Native<ffi.Void Function(Sound, ffi.Float)>()
external void SetSoundPitch(Sound sound, double pitch);

@ffi.Native<ffi.Void Function(Sound, ffi.Float)>()
external void SetSoundPan(Sound sound, double pan);

@ffi.Native<Wave Function(Wave)>()
external Wave WaveCopy(Wave wave);

@ffi.Native<ffi.Void Function(ffi.Pointer<Wave>, ffi.Int, ffi.Int)>()
external void WaveCrop(ffi.Pointer<Wave> wave, int initFrame, int finalFrame);

@ffi.Native<ffi.Void Function(ffi.Pointer<Wave>, ffi.Int, ffi.Int, ffi.Int)>()
external void WaveFormat(
  ffi.Pointer<Wave> wave,
  int sampleRate,
  int sampleSize,
  int channels,
);

@ffi.Native<ffi.Pointer<ffi.Float> Function(Wave)>()
external ffi.Pointer<ffi.Float> LoadWaveSamples(Wave wave);

@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Float>)>()
external void UnloadWaveSamples(ffi.Pointer<ffi.Float> samples);

@ffi.Native<Music Function(ffi.Pointer<ffi.Char>)>()
external Music LoadMusicStream(ffi.Pointer<ffi.Char> fileName);

@ffi.Native<
  Music Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.UnsignedChar>, ffi.Int)
>()
external Music LoadMusicStreamFromMemory(
  ffi.Pointer<ffi.Char> fileType,
  ffi.Pointer<ffi.UnsignedChar> data,
  int dataSize,
);

@ffi.Native<ffi.Bool Function(Music)>()
external bool IsMusicValid(Music music);

@ffi.Native<ffi.Void Function(Music)>()
external void UnloadMusicStream(Music music);

@ffi.Native<ffi.Void Function(Music)>()
external void PlayMusicStream(Music music);

@ffi.Native<ffi.Bool Function(Music)>()
external bool IsMusicStreamPlaying(Music music);

@ffi.Native<ffi.Void Function(Music)>()
external void UpdateMusicStream(Music music);

@ffi.Native<ffi.Void Function(Music)>()
external void StopMusicStream(Music music);

@ffi.Native<ffi.Void Function(Music)>()
external void PauseMusicStream(Music music);

@ffi.Native<ffi.Void Function(Music)>()
external void ResumeMusicStream(Music music);

@ffi.Native<ffi.Void Function(Music, ffi.Float)>()
external void SeekMusicStream(Music music, double position);

@ffi.Native<ffi.Void Function(Music, ffi.Float)>()
external void SetMusicVolume(Music music, double volume);

@ffi.Native<ffi.Void Function(Music, ffi.Float)>()
external void SetMusicPitch(Music music, double pitch);

@ffi.Native<ffi.Void Function(Music, ffi.Float)>()
external void SetMusicPan(Music music, double pan);

@ffi.Native<ffi.Float Function(Music)>()
external double GetMusicTimeLength(Music music);

@ffi.Native<ffi.Float Function(Music)>()
external double GetMusicTimePlayed(Music music);

@ffi.Native<
  AudioStream Function(ffi.UnsignedInt, ffi.UnsignedInt, ffi.UnsignedInt)
>()
external AudioStream LoadAudioStream(
  int sampleRate,
  int sampleSize,
  int channels,
);

@ffi.Native<ffi.Bool Function(AudioStream)>()
external bool IsAudioStreamValid(AudioStream stream);

@ffi.Native<ffi.Void Function(AudioStream)>()
external void UnloadAudioStream(AudioStream stream);

@ffi.Native<ffi.Void Function(AudioStream, ffi.Pointer<ffi.Void>, ffi.Int)>()
external void UpdateAudioStream(
  AudioStream stream,
  ffi.Pointer<ffi.Void> data,
  int frameCount,
);

@ffi.Native<ffi.Bool Function(AudioStream)>()
external bool IsAudioStreamProcessed(AudioStream stream);

@ffi.Native<ffi.Void Function(AudioStream)>()
external void PlayAudioStream(AudioStream stream);

@ffi.Native<ffi.Void Function(AudioStream)>()
external void PauseAudioStream(AudioStream stream);

@ffi.Native<ffi.Void Function(AudioStream)>()
external void ResumeAudioStream(AudioStream stream);

@ffi.Native<ffi.Bool Function(AudioStream)>()
external bool IsAudioStreamPlaying(AudioStream stream);

@ffi.Native<ffi.Void Function(AudioStream)>()
external void StopAudioStream(AudioStream stream);

@ffi.Native<ffi.Void Function(AudioStream, ffi.Float)>()
external void SetAudioStreamVolume(AudioStream stream, double volume);

@ffi.Native<ffi.Void Function(AudioStream, ffi.Float)>()
external void SetAudioStreamPitch(AudioStream stream, double pitch);

@ffi.Native<ffi.Void Function(AudioStream, ffi.Float)>()
external void SetAudioStreamPan(AudioStream stream, double pan);

@ffi.Native<ffi.Void Function(ffi.Int)>()
external void SetAudioStreamBufferSizeDefault(int size);

@ffi.Native<ffi.Void Function(AudioStream, AudioCallback)>()
external void SetAudioStreamCallback(
  AudioStream stream,
  AudioCallback callback,
);

@ffi.Native<ffi.Void Function(AudioStream, AudioCallback)>()
external void AttachAudioStreamProcessor(
  AudioStream stream,
  AudioCallback processor,
);

@ffi.Native<ffi.Void Function(AudioStream, AudioCallback)>()
external void DetachAudioStreamProcessor(
  AudioStream stream,
  AudioCallback processor,
);

@ffi.Native<ffi.Void Function(AudioCallback)>()
external void AttachAudioMixedProcessor(AudioCallback processor);

@ffi.Native<ffi.Void Function(AudioCallback)>()
external void DetachAudioMixedProcessor(AudioCallback processor);

@ffi.Native<ffi.Void Function(ffi.Int)>()
external void rlMatrixMode(int mode);

@ffi.Native<ffi.Void Function()>()
external void rlPushMatrix();

@ffi.Native<ffi.Void Function()>()
external void rlPopMatrix();

@ffi.Native<ffi.Void Function()>()
external void rlLoadIdentity();

@ffi.Native<ffi.Void Function(ffi.Float, ffi.Float, ffi.Float)>()
external void rlTranslatef(double x, double y, double z);

@ffi.Native<ffi.Void Function(ffi.Float, ffi.Float, ffi.Float, ffi.Float)>()
external void rlRotatef(double angle, double x, double y, double z);

@ffi.Native<ffi.Void Function(ffi.Float, ffi.Float, ffi.Float)>()
external void rlScalef(double x, double y, double z);

@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Float>)>()
external void rlMultMatrixf(ffi.Pointer<ffi.Float> matf);

@ffi.Native<
  ffi.Void Function(
    ffi.Double,
    ffi.Double,
    ffi.Double,
    ffi.Double,
    ffi.Double,
    ffi.Double,
  )
>()
external void rlFrustum(
  double left,
  double right,
  double bottom,
  double top,
  double znear,
  double zfar,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Double,
    ffi.Double,
    ffi.Double,
    ffi.Double,
    ffi.Double,
    ffi.Double,
  )
>()
external void rlOrtho(
  double left,
  double right,
  double bottom,
  double top,
  double znear,
  double zfar,
);

@ffi.Native<ffi.Void Function(ffi.Int, ffi.Int, ffi.Int, ffi.Int)>()
external void rlViewport(int x, int y, int width, int height);

@ffi.Native<ffi.Void Function(ffi.Double, ffi.Double)>()
external void rlSetClipPlanes(double nearPlane, double farPlane);

@ffi.Native<ffi.Double Function()>()
external double rlGetCullDistanceNear();

@ffi.Native<ffi.Double Function()>()
external double rlGetCullDistanceFar();

@ffi.Native<ffi.Void Function(ffi.Int)>()
external void rlBegin(int mode);

@ffi.Native<ffi.Void Function()>()
external void rlEnd();

@ffi.Native<ffi.Void Function(ffi.Int, ffi.Int)>()
external void rlVertex2i(int x, int y);

@ffi.Native<ffi.Void Function(ffi.Float, ffi.Float)>()
external void rlVertex2f(double x, double y);

@ffi.Native<ffi.Void Function(ffi.Float, ffi.Float, ffi.Float)>()
external void rlVertex3f(double x, double y, double z);

@ffi.Native<ffi.Void Function(ffi.Float, ffi.Float)>()
external void rlTexCoord2f(double x, double y);

@ffi.Native<ffi.Void Function(ffi.Float, ffi.Float, ffi.Float)>()
external void rlNormal3f(double x, double y, double z);

@ffi.Native<
  ffi.Void Function(
    ffi.UnsignedChar,
    ffi.UnsignedChar,
    ffi.UnsignedChar,
    ffi.UnsignedChar,
  )
>()
external void rlColor4ub(int r, int g, int b, int a);

@ffi.Native<ffi.Void Function(ffi.Float, ffi.Float, ffi.Float)>()
external void rlColor3f(double x, double y, double z);

@ffi.Native<ffi.Void Function(ffi.Float, ffi.Float, ffi.Float, ffi.Float)>()
external void rlColor4f(double x, double y, double z, double w);

@ffi.Native<ffi.Bool Function(ffi.UnsignedInt)>()
external bool rlEnableVertexArray(int vaoId);

@ffi.Native<ffi.Void Function()>()
external void rlDisableVertexArray();

@ffi.Native<ffi.Void Function(ffi.UnsignedInt)>()
external void rlEnableVertexBuffer(int id);

@ffi.Native<ffi.Void Function()>()
external void rlDisableVertexBuffer();

@ffi.Native<ffi.Void Function(ffi.UnsignedInt)>()
external void rlEnableVertexBufferElement(int id);

@ffi.Native<ffi.Void Function()>()
external void rlDisableVertexBufferElement();

@ffi.Native<ffi.Void Function(ffi.UnsignedInt)>()
external void rlEnableVertexAttribute(int index);

@ffi.Native<ffi.Void Function(ffi.UnsignedInt)>()
external void rlDisableVertexAttribute(int index);

@ffi.Native<ffi.Void Function(ffi.Int, ffi.Pointer<ffi.Void>)>()
external void rlEnableStatePointer(
  int vertexAttribType,
  ffi.Pointer<ffi.Void> buffer,
);

@ffi.Native<ffi.Void Function(ffi.Int)>()
external void rlDisableStatePointer(int vertexAttribType);

@ffi.Native<ffi.Void Function(ffi.Int)>()
external void rlActiveTextureSlot(int slot);

@ffi.Native<ffi.Void Function(ffi.UnsignedInt)>()
external void rlEnableTexture(int id);

@ffi.Native<ffi.Void Function()>()
external void rlDisableTexture();

@ffi.Native<ffi.Void Function(ffi.UnsignedInt)>()
external void rlEnableTextureCubemap(int id);

@ffi.Native<ffi.Void Function()>()
external void rlDisableTextureCubemap();

@ffi.Native<ffi.Void Function(ffi.UnsignedInt, ffi.Int, ffi.Int)>()
external void rlTextureParameters(int id, int param, int value);

@ffi.Native<ffi.Void Function(ffi.UnsignedInt, ffi.Int, ffi.Int)>()
external void rlCubemapParameters(int id, int param, int value);

@ffi.Native<ffi.Void Function(ffi.UnsignedInt)>()
external void rlEnableShader(int id);

@ffi.Native<ffi.Void Function()>()
external void rlDisableShader();

@ffi.Native<ffi.Void Function(ffi.UnsignedInt)>()
external void rlEnableFramebuffer(int id);

@ffi.Native<ffi.Void Function()>()
external void rlDisableFramebuffer();

@ffi.Native<ffi.UnsignedInt Function()>()
external int rlGetActiveFramebuffer();

@ffi.Native<ffi.Void Function(ffi.Int)>()
external void rlActiveDrawBuffers(int count);

@ffi.Native<
  ffi.Void Function(
    ffi.Int,
    ffi.Int,
    ffi.Int,
    ffi.Int,
    ffi.Int,
    ffi.Int,
    ffi.Int,
    ffi.Int,
    ffi.Int,
  )
>()
external void rlBlitFramebuffer(
  int srcX,
  int srcY,
  int srcWidth,
  int srcHeight,
  int dstX,
  int dstY,
  int dstWidth,
  int dstHeight,
  int bufferMask,
);

@ffi.Native<ffi.Void Function(ffi.UnsignedInt, ffi.UnsignedInt)>()
external void rlBindFramebuffer(int target, int framebuffer);

@ffi.Native<ffi.Void Function()>()
external void rlEnableColorBlend();

@ffi.Native<ffi.Void Function()>()
external void rlDisableColorBlend();

@ffi.Native<ffi.Void Function()>()
external void rlEnableDepthTest();

@ffi.Native<ffi.Void Function()>()
external void rlDisableDepthTest();

@ffi.Native<ffi.Void Function()>()
external void rlEnableDepthMask();

@ffi.Native<ffi.Void Function()>()
external void rlDisableDepthMask();

@ffi.Native<ffi.Void Function()>()
external void rlEnableBackfaceCulling();

@ffi.Native<ffi.Void Function()>()
external void rlDisableBackfaceCulling();

@ffi.Native<ffi.Void Function(ffi.Bool, ffi.Bool, ffi.Bool, ffi.Bool)>()
external void rlColorMask(bool r, bool g, bool b, bool a);

@ffi.Native<ffi.Void Function(ffi.Int)>()
external void rlSetCullFace(int mode);

@ffi.Native<ffi.Void Function()>()
external void rlEnableScissorTest();

@ffi.Native<ffi.Void Function()>()
external void rlDisableScissorTest();

@ffi.Native<ffi.Void Function(ffi.Int, ffi.Int, ffi.Int, ffi.Int)>()
external void rlScissor(int x, int y, int width, int height);

@ffi.Native<ffi.Void Function()>()
external void rlEnablePointMode();

@ffi.Native<ffi.Void Function()>()
external void rlDisablePointMode();

@ffi.Native<ffi.Void Function(ffi.Float)>()
external void rlSetPointSize(double size);

@ffi.Native<ffi.Float Function()>()
external double rlGetPointSize();

@ffi.Native<ffi.Void Function()>()
external void rlEnableWireMode();

@ffi.Native<ffi.Void Function()>()
external void rlDisableWireMode();

@ffi.Native<ffi.Void Function(ffi.Float)>()
external void rlSetLineWidth(double width);

@ffi.Native<ffi.Float Function()>()
external double rlGetLineWidth();

@ffi.Native<ffi.Void Function()>()
external void rlEnableSmoothLines();

@ffi.Native<ffi.Void Function()>()
external void rlDisableSmoothLines();

@ffi.Native<ffi.Void Function()>()
external void rlEnableStereoRender();

@ffi.Native<ffi.Void Function()>()
external void rlDisableStereoRender();

@ffi.Native<ffi.Bool Function()>()
external bool rlIsStereoRenderEnabled();

@ffi.Native<
  ffi.Void Function(
    ffi.UnsignedChar,
    ffi.UnsignedChar,
    ffi.UnsignedChar,
    ffi.UnsignedChar,
  )
>()
external void rlClearColor(int r, int g, int b, int a);

@ffi.Native<ffi.Void Function()>()
external void rlClearScreenBuffers();

@ffi.Native<ffi.Void Function()>()
external void rlCheckErrors();

@ffi.Native<ffi.Void Function(ffi.Int)>()
external void rlSetBlendMode(int mode);

@ffi.Native<ffi.Void Function(ffi.Int, ffi.Int, ffi.Int)>()
external void rlSetBlendFactors(
  int glSrcFactor,
  int glDstFactor,
  int glEquation,
);

@ffi.Native<
  ffi.Void Function(ffi.Int, ffi.Int, ffi.Int, ffi.Int, ffi.Int, ffi.Int)
>()
external void rlSetBlendFactorsSeparate(
  int glSrcRGB,
  int glDstRGB,
  int glSrcAlpha,
  int glDstAlpha,
  int glEqRGB,
  int glEqAlpha,
);

@ffi.Native<ffi.Void Function(ffi.Int, ffi.Int)>()
external void rlglInit(int width, int height);

@ffi.Native<ffi.Void Function()>()
external void rlglClose();

@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Void>)>()
external void rlLoadExtensions(ffi.Pointer<ffi.Void> loader);

@ffi.Native<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Char>)>()
external ffi.Pointer<ffi.Void> rlGetProcAddress(ffi.Pointer<ffi.Char> procName);

@ffi.Native<ffi.Int Function()>()
external int rlGetVersion();

@ffi.Native<ffi.Void Function(ffi.Int)>()
external void rlSetFramebufferWidth(int width);

@ffi.Native<ffi.Int Function()>()
external int rlGetFramebufferWidth();

@ffi.Native<ffi.Void Function(ffi.Int)>()
external void rlSetFramebufferHeight(int height);

@ffi.Native<ffi.Int Function()>()
external int rlGetFramebufferHeight();

@ffi.Native<ffi.UnsignedInt Function()>()
external int rlGetTextureIdDefault();

@ffi.Native<ffi.UnsignedInt Function()>()
external int rlGetShaderIdDefault();

@ffi.Native<ffi.Pointer<ffi.Int> Function()>()
external ffi.Pointer<ffi.Int> rlGetShaderLocsDefault();

@ffi.Native<rlRenderBatch Function(ffi.Int, ffi.Int)>()
external rlRenderBatch rlLoadRenderBatch(int numBuffers, int bufferElements);

@ffi.Native<ffi.Void Function(rlRenderBatch)>()
external void rlUnloadRenderBatch(rlRenderBatch batch);

@ffi.Native<ffi.Void Function(ffi.Pointer<rlRenderBatch>)>()
external void rlDrawRenderBatch(ffi.Pointer<rlRenderBatch> batch);

@ffi.Native<ffi.Void Function(ffi.Pointer<rlRenderBatch>)>()
external void rlSetRenderBatchActive(ffi.Pointer<rlRenderBatch> batch);

@ffi.Native<ffi.Void Function()>()
external void rlDrawRenderBatchActive();

@ffi.Native<ffi.Bool Function(ffi.Int)>()
external bool rlCheckRenderBatchLimit(int vCount);

@ffi.Native<ffi.Void Function(ffi.UnsignedInt)>()
external void rlSetTexture(int id);

@ffi.Native<ffi.UnsignedInt Function()>()
external int rlLoadVertexArray();

@ffi.Native<
  ffi.UnsignedInt Function(ffi.Pointer<ffi.Void>, ffi.Int, ffi.Bool)
>()
external int rlLoadVertexBuffer(
  ffi.Pointer<ffi.Void> buffer,
  int size,
  bool dynamic,
);

@ffi.Native<
  ffi.UnsignedInt Function(ffi.Pointer<ffi.Void>, ffi.Int, ffi.Bool)
>()
external int rlLoadVertexBufferElement(
  ffi.Pointer<ffi.Void> buffer,
  int size,
  bool dynamic,
);

@ffi.Native<
  ffi.Void Function(ffi.UnsignedInt, ffi.Pointer<ffi.Void>, ffi.Int, ffi.Int)
>()
external void rlUpdateVertexBuffer(
  int bufferId,
  ffi.Pointer<ffi.Void> data,
  int dataSize,
  int offset,
);

@ffi.Native<
  ffi.Void Function(ffi.UnsignedInt, ffi.Pointer<ffi.Void>, ffi.Int, ffi.Int)
>()
external void rlUpdateVertexBufferElements(
  int id,
  ffi.Pointer<ffi.Void> data,
  int dataSize,
  int offset,
);

@ffi.Native<ffi.Void Function(ffi.UnsignedInt)>()
external void rlUnloadVertexArray(int vaoId);

@ffi.Native<ffi.Void Function(ffi.UnsignedInt)>()
external void rlUnloadVertexBuffer(int vboId);

@ffi.Native<
  ffi.Void Function(
    ffi.UnsignedInt,
    ffi.Int,
    ffi.Int,
    ffi.Bool,
    ffi.Int,
    ffi.Int,
  )
>()
external void rlSetVertexAttribute(
  int index,
  int compSize,
  int type,
  bool normalized,
  int stride,
  int offset,
);

@ffi.Native<ffi.Void Function(ffi.UnsignedInt, ffi.Int)>()
external void rlSetVertexAttributeDivisor(int index, int divisor);

@ffi.Native<
  ffi.Void Function(ffi.Int, ffi.Pointer<ffi.Void>, ffi.Int, ffi.Int)
>()
external void rlSetVertexAttributeDefault(
  int locIndex,
  ffi.Pointer<ffi.Void> value,
  int attribType,
  int count,
);

@ffi.Native<ffi.Void Function(ffi.Int, ffi.Int)>()
external void rlDrawVertexArray(int offset, int count);

@ffi.Native<ffi.Void Function(ffi.Int, ffi.Int, ffi.Pointer<ffi.Void>)>()
external void rlDrawVertexArrayElements(
  int offset,
  int count,
  ffi.Pointer<ffi.Void> buffer,
);

@ffi.Native<ffi.Void Function(ffi.Int, ffi.Int, ffi.Int)>()
external void rlDrawVertexArrayInstanced(int offset, int count, int instances);

@ffi.Native<
  ffi.Void Function(ffi.Int, ffi.Int, ffi.Pointer<ffi.Void>, ffi.Int)
>()
external void rlDrawVertexArrayElementsInstanced(
  int offset,
  int count,
  ffi.Pointer<ffi.Void> buffer,
  int instances,
);

@ffi.Native<
  ffi.UnsignedInt Function(
    ffi.Pointer<ffi.Void>,
    ffi.Int,
    ffi.Int,
    ffi.Int,
    ffi.Int,
  )
>()
external int rlLoadTexture(
  ffi.Pointer<ffi.Void> data,
  int width,
  int height,
  int format,
  int mipmapCount,
);

@ffi.Native<ffi.UnsignedInt Function(ffi.Int, ffi.Int, ffi.Bool)>()
external int rlLoadTextureDepth(int width, int height, bool useRenderBuffer);

@ffi.Native<
  ffi.UnsignedInt Function(ffi.Pointer<ffi.Void>, ffi.Int, ffi.Int, ffi.Int)
>()
external int rlLoadTextureCubemap(
  ffi.Pointer<ffi.Void> data,
  int size,
  int format,
  int mipmapCount,
);

@ffi.Native<
  ffi.Void Function(
    ffi.UnsignedInt,
    ffi.Int,
    ffi.Int,
    ffi.Int,
    ffi.Int,
    ffi.Int,
    ffi.Pointer<ffi.Void>,
  )
>()
external void rlUpdateTexture(
  int id,
  int offsetX,
  int offsetY,
  int width,
  int height,
  int format,
  ffi.Pointer<ffi.Void> data,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Int,
    ffi.Pointer<ffi.UnsignedInt>,
    ffi.Pointer<ffi.UnsignedInt>,
    ffi.Pointer<ffi.UnsignedInt>,
  )
>()
external void rlGetGlTextureFormats(
  int format,
  ffi.Pointer<ffi.UnsignedInt> glInternalFormat,
  ffi.Pointer<ffi.UnsignedInt> glFormat,
  ffi.Pointer<ffi.UnsignedInt> glType,
);

@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.UnsignedInt)>()
external ffi.Pointer<ffi.Char> rlGetPixelFormatName(int format);

@ffi.Native<ffi.Void Function(ffi.UnsignedInt)>()
external void rlUnloadTexture(int id);

@ffi.Native<
  ffi.Void Function(
    ffi.UnsignedInt,
    ffi.Int,
    ffi.Int,
    ffi.Int,
    ffi.Pointer<ffi.Int>,
  )
>()
external void rlGenTextureMipmaps(
  int id,
  int width,
  int height,
  int format,
  ffi.Pointer<ffi.Int> mipmaps,
);

@ffi.Native<
  ffi.Pointer<ffi.Void> Function(ffi.UnsignedInt, ffi.Int, ffi.Int, ffi.Int)
>()
external ffi.Pointer<ffi.Void> rlReadTexturePixels(
  int id,
  int width,
  int height,
  int format,
);

@ffi.Native<ffi.Pointer<ffi.UnsignedChar> Function(ffi.Int, ffi.Int)>()
external ffi.Pointer<ffi.UnsignedChar> rlReadScreenPixels(
  int width,
  int height,
);

@ffi.Native<ffi.UnsignedInt Function()>()
external int rlLoadFramebuffer();

@ffi.Native<
  ffi.Void Function(ffi.UnsignedInt, ffi.UnsignedInt, ffi.Int, ffi.Int, ffi.Int)
>()
external void rlFramebufferAttach(
  int fboId,
  int texId,
  int attachType,
  int texType,
  int mipLevel,
);

@ffi.Native<ffi.Bool Function(ffi.UnsignedInt)>()
external bool rlFramebufferComplete(int id);

@ffi.Native<ffi.Void Function(ffi.UnsignedInt)>()
external void rlUnloadFramebuffer(int id);

@ffi.Native<
  ffi.Void Function(
    ffi.Int,
    ffi.Int,
    ffi.Int,
    ffi.Int,
    ffi.Int,
    ffi.Pointer<ffi.Void>,
  )
>()
external void rlCopyFramebuffer(
  int x,
  int y,
  int width,
  int height,
  int format,
  ffi.Pointer<ffi.Void> pixels,
);

@ffi.Native<ffi.Void Function(ffi.Int, ffi.Int)>()
external void rlResizeFramebuffer(int width, int height);

@ffi.Native<
  ffi.UnsignedInt Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)
>()
external int rlLoadShaderCode(
  ffi.Pointer<ffi.Char> vsCode,
  ffi.Pointer<ffi.Char> fsCode,
);

@ffi.Native<ffi.UnsignedInt Function(ffi.Pointer<ffi.Char>, ffi.Int)>()
external int rlCompileShader(ffi.Pointer<ffi.Char> shaderCode, int type);

@ffi.Native<ffi.UnsignedInt Function(ffi.UnsignedInt, ffi.UnsignedInt)>()
external int rlLoadShaderProgram(int vShaderId, int fShaderId);

@ffi.Native<ffi.Void Function(ffi.UnsignedInt)>()
external void rlUnloadShaderProgram(int id);

@ffi.Native<ffi.Int Function(ffi.UnsignedInt, ffi.Pointer<ffi.Char>)>()
external int rlGetLocationUniform(
  int shaderId,
  ffi.Pointer<ffi.Char> uniformName,
);

@ffi.Native<ffi.Int Function(ffi.UnsignedInt, ffi.Pointer<ffi.Char>)>()
external int rlGetLocationAttrib(
  int shaderId,
  ffi.Pointer<ffi.Char> attribName,
);

@ffi.Native<
  ffi.Void Function(ffi.Int, ffi.Pointer<ffi.Void>, ffi.Int, ffi.Int)
>()
external void rlSetUniform(
  int locIndex,
  ffi.Pointer<ffi.Void> value,
  int uniformType,
  int count,
);

@ffi.Native<ffi.Void Function(ffi.Int, Matrix)>()
external void rlSetUniformMatrix(int locIndex, Matrix mat);

@ffi.Native<ffi.Void Function(ffi.Int, ffi.Pointer<Matrix>, ffi.Int)>()
external void rlSetUniformMatrices(
  int locIndex,
  ffi.Pointer<Matrix> mat,
  int count,
);

@ffi.Native<ffi.Void Function(ffi.Int, ffi.UnsignedInt)>()
external void rlSetUniformSampler(int locIndex, int textureId);

@ffi.Native<ffi.Void Function(ffi.UnsignedInt, ffi.Pointer<ffi.Int>)>()
external void rlSetShader(int id, ffi.Pointer<ffi.Int> locs);

@ffi.Native<ffi.UnsignedInt Function(ffi.UnsignedInt)>()
external int rlLoadComputeShaderProgram(int shaderId);

@ffi.Native<
  ffi.Void Function(ffi.UnsignedInt, ffi.UnsignedInt, ffi.UnsignedInt)
>()
external void rlComputeShaderDispatch(int groupX, int groupY, int groupZ);

@ffi.Native<
  ffi.UnsignedInt Function(ffi.UnsignedInt, ffi.Pointer<ffi.Void>, ffi.Int)
>()
external int rlLoadShaderBuffer(
  int size,
  ffi.Pointer<ffi.Void> data,
  int usageHint,
);

@ffi.Native<ffi.Void Function(ffi.UnsignedInt)>()
external void rlUnloadShaderBuffer(int ssboId);

@ffi.Native<
  ffi.Void Function(
    ffi.UnsignedInt,
    ffi.Pointer<ffi.Void>,
    ffi.UnsignedInt,
    ffi.UnsignedInt,
  )
>()
external void rlUpdateShaderBuffer(
  int id,
  ffi.Pointer<ffi.Void> data,
  int dataSize,
  int offset,
);

@ffi.Native<ffi.Void Function(ffi.UnsignedInt, ffi.UnsignedInt)>()
external void rlBindShaderBuffer(int id, int index);

@ffi.Native<
  ffi.Void Function(
    ffi.UnsignedInt,
    ffi.Pointer<ffi.Void>,
    ffi.UnsignedInt,
    ffi.UnsignedInt,
  )
>()
external void rlReadShaderBuffer(
  int id,
  ffi.Pointer<ffi.Void> dest,
  int count,
  int offset,
);

@ffi.Native<
  ffi.Void Function(
    ffi.UnsignedInt,
    ffi.UnsignedInt,
    ffi.UnsignedInt,
    ffi.UnsignedInt,
    ffi.UnsignedInt,
  )
>()
external void rlCopyShaderBuffer(
  int destId,
  int srcId,
  int destOffset,
  int srcOffset,
  int count,
);

@ffi.Native<ffi.UnsignedInt Function(ffi.UnsignedInt)>()
external int rlGetShaderBufferSize(int id);

@ffi.Native<
  ffi.Void Function(ffi.UnsignedInt, ffi.UnsignedInt, ffi.Int, ffi.Bool)
>()
external void rlBindImageTexture(int id, int index, int format, bool readonly);

@ffi.Native<Matrix Function()>()
external Matrix rlGetMatrixModelview();

@ffi.Native<Matrix Function()>()
external Matrix rlGetMatrixProjection();

@ffi.Native<Matrix Function()>()
external Matrix rlGetMatrixTransform();

@ffi.Native<Matrix Function(ffi.Int)>()
external Matrix rlGetMatrixProjectionStereo(int eye);

@ffi.Native<Matrix Function(ffi.Int)>()
external Matrix rlGetMatrixViewOffsetStereo(int eye);

@ffi.Native<ffi.Void Function(Matrix)>()
external void rlSetMatrixProjection(Matrix proj);

@ffi.Native<ffi.Void Function(Matrix)>()
external void rlSetMatrixModelview(Matrix view);

@ffi.Native<ffi.Void Function(Matrix, Matrix)>()
external void rlSetMatrixProjectionStereo(Matrix right, Matrix left);

@ffi.Native<ffi.Void Function(Matrix, Matrix)>()
external void rlSetMatrixViewOffsetStereo(Matrix right, Matrix left);

@ffi.Native<ffi.Void Function()>()
external void rlLoadDrawCube();

@ffi.Native<ffi.Void Function()>()
external void rlLoadDrawQuad();

final class Vector2 extends ffi.Struct {
  @ffi.Float()
  external double x;

  @ffi.Float()
  external double y;
}

final class Vector3 extends ffi.Struct {
  @ffi.Float()
  external double x;

  @ffi.Float()
  external double y;

  @ffi.Float()
  external double z;
}

final class Vector4 extends ffi.Struct {
  @ffi.Float()
  external double x;

  @ffi.Float()
  external double y;

  @ffi.Float()
  external double z;

  @ffi.Float()
  external double w;
}

typedef Quaternion = Vector4;

final class Matrix extends ffi.Struct {
  @ffi.Float()
  external double m0;

  @ffi.Float()
  external double m4;

  @ffi.Float()
  external double m8;

  @ffi.Float()
  external double m12;

  @ffi.Float()
  external double m1;

  @ffi.Float()
  external double m5;

  @ffi.Float()
  external double m9;

  @ffi.Float()
  external double m13;

  @ffi.Float()
  external double m2;

  @ffi.Float()
  external double m6;

  @ffi.Float()
  external double m10;

  @ffi.Float()
  external double m14;

  @ffi.Float()
  external double m3;

  @ffi.Float()
  external double m7;

  @ffi.Float()
  external double m11;

  @ffi.Float()
  external double m15;
}

final class Color extends ffi.Struct {
  @ffi.UnsignedChar()
  external int r;

  @ffi.UnsignedChar()
  external int g;

  @ffi.UnsignedChar()
  external int b;

  @ffi.UnsignedChar()
  external int a;
}

final class Rectangle extends ffi.Struct {
  @ffi.Float()
  external double x;

  @ffi.Float()
  external double y;

  @ffi.Float()
  external double width;

  @ffi.Float()
  external double height;
}

final class Image extends ffi.Struct {
  external ffi.Pointer<ffi.Void> data;

  @ffi.Int()
  external int width;

  @ffi.Int()
  external int height;

  @ffi.Int()
  external int mipmaps;

  @ffi.Int()
  external int format;
}

final class Texture extends ffi.Struct {
  @ffi.UnsignedInt()
  external int id;

  @ffi.Int()
  external int width;

  @ffi.Int()
  external int height;

  @ffi.Int()
  external int mipmaps;

  @ffi.Int()
  external int format;
}

typedef Texture2D = Texture;
typedef TextureCubemap = Texture;

final class RenderTexture extends ffi.Struct {
  @ffi.UnsignedInt()
  external int id;

  external Texture texture;

  external Texture depth;
}

typedef RenderTexture2D = RenderTexture;

final class NPatchInfo extends ffi.Struct {
  external Rectangle source;

  @ffi.Int()
  external int left;

  @ffi.Int()
  external int top;

  @ffi.Int()
  external int right;

  @ffi.Int()
  external int bottom;

  @ffi.Int()
  external int layout;
}

final class GlyphInfo extends ffi.Struct {
  @ffi.Int()
  external int value;

  @ffi.Int()
  external int offsetX;

  @ffi.Int()
  external int offsetY;

  @ffi.Int()
  external int advanceX;

  external Image image;
}

final class Font extends ffi.Struct {
  @ffi.Int()
  external int baseSize;

  @ffi.Int()
  external int glyphCount;

  @ffi.Int()
  external int glyphPadding;

  external Texture2D texture;

  external ffi.Pointer<Rectangle> recs;

  external ffi.Pointer<GlyphInfo> glyphs;
}

final class Camera3D extends ffi.Struct {
  external Vector3 position;

  external Vector3 target;

  external Vector3 up;

  @ffi.Float()
  external double fovy;

  @ffi.Int()
  external int projection;
}

typedef Camera = Camera3D;

final class Camera2D extends ffi.Struct {
  external Vector2 offset;

  external Vector2 target;

  @ffi.Float()
  external double rotation;

  @ffi.Float()
  external double zoom;
}

final class Mesh extends ffi.Struct {
  @ffi.Int()
  external int vertexCount;

  @ffi.Int()
  external int triangleCount;

  external ffi.Pointer<ffi.Float> vertices;

  external ffi.Pointer<ffi.Float> texcoords;

  external ffi.Pointer<ffi.Float> texcoords2;

  external ffi.Pointer<ffi.Float> normals;

  external ffi.Pointer<ffi.Float> tangents;

  external ffi.Pointer<ffi.UnsignedChar> colors;

  external ffi.Pointer<ffi.UnsignedShort> indices;

  external ffi.Pointer<ffi.Float> animVertices;

  external ffi.Pointer<ffi.Float> animNormals;

  external ffi.Pointer<ffi.UnsignedChar> boneIds;

  external ffi.Pointer<ffi.Float> boneWeights;

  external ffi.Pointer<Matrix> boneMatrices;

  @ffi.Int()
  external int boneCount;

  @ffi.UnsignedInt()
  external int vaoId;

  external ffi.Pointer<ffi.UnsignedInt> vboId;
}

final class Shader extends ffi.Struct {
  @ffi.UnsignedInt()
  external int id;

  external ffi.Pointer<ffi.Int> locs;
}

final class MaterialMap extends ffi.Struct {
  external Texture2D texture;

  external Color color;

  @ffi.Float()
  external double value;
}

final class Material extends ffi.Struct {
  external Shader shader;

  external ffi.Pointer<MaterialMap> maps;

  @ffi.Array.multi([4])
  external ffi.Array<ffi.Float> params;
}

final class Transform extends ffi.Struct {
  external Vector3 translation;

  external Quaternion rotation;

  external Vector3 scale;
}

final class BoneInfo extends ffi.Struct {
  @ffi.Array.multi([32])
  external ffi.Array<ffi.Char> name;

  @ffi.Int()
  external int parent;
}

final class Model extends ffi.Struct {
  external Matrix transform;

  @ffi.Int()
  external int meshCount;

  @ffi.Int()
  external int materialCount;

  external ffi.Pointer<Mesh> meshes;

  external ffi.Pointer<Material> materials;

  external ffi.Pointer<ffi.Int> meshMaterial;

  @ffi.Int()
  external int boneCount;

  external ffi.Pointer<BoneInfo> bones;

  external ffi.Pointer<Transform> bindPose;
}

final class ModelAnimation extends ffi.Struct {
  @ffi.Int()
  external int boneCount;

  @ffi.Int()
  external int frameCount;

  external ffi.Pointer<BoneInfo> bones;

  external ffi.Pointer<ffi.Pointer<Transform>> framePoses;

  @ffi.Array.multi([32])
  external ffi.Array<ffi.Char> name;
}

final class Ray extends ffi.Struct {
  external Vector3 position;

  external Vector3 direction;
}

final class RayCollision extends ffi.Struct {
  @ffi.Bool()
  external bool hit;

  @ffi.Float()
  external double distance;

  external Vector3 point;

  external Vector3 normal;
}

final class BoundingBox extends ffi.Struct {
  external Vector3 min;

  external Vector3 max;
}

final class Wave extends ffi.Struct {
  @ffi.UnsignedInt()
  external int frameCount;

  @ffi.UnsignedInt()
  external int sampleRate;

  @ffi.UnsignedInt()
  external int sampleSize;

  @ffi.UnsignedInt()
  external int channels;

  external ffi.Pointer<ffi.Void> data;
}

final class rAudioBuffer extends ffi.Opaque {}

final class rAudioProcessor extends ffi.Opaque {}

final class AudioStream extends ffi.Struct {
  external ffi.Pointer<rAudioBuffer> buffer;

  external ffi.Pointer<rAudioProcessor> processor;

  @ffi.UnsignedInt()
  external int sampleRate;

  @ffi.UnsignedInt()
  external int sampleSize;

  @ffi.UnsignedInt()
  external int channels;
}

final class Sound extends ffi.Struct {
  external AudioStream stream;

  @ffi.UnsignedInt()
  external int frameCount;
}

final class Music extends ffi.Struct {
  external AudioStream stream;

  @ffi.UnsignedInt()
  external int frameCount;

  @ffi.Bool()
  external bool looping;

  @ffi.Int()
  external int ctxType;

  external ffi.Pointer<ffi.Void> ctxData;
}

final class VrDeviceInfo extends ffi.Struct {
  @ffi.Int()
  external int hResolution;

  @ffi.Int()
  external int vResolution;

  @ffi.Float()
  external double hScreenSize;

  @ffi.Float()
  external double vScreenSize;

  @ffi.Float()
  external double eyeToScreenDistance;

  @ffi.Float()
  external double lensSeparationDistance;

  @ffi.Float()
  external double interpupillaryDistance;

  @ffi.Array.multi([4])
  external ffi.Array<ffi.Float> lensDistortionValues;

  @ffi.Array.multi([4])
  external ffi.Array<ffi.Float> chromaAbCorrection;
}

final class VrStereoConfig extends ffi.Struct {
  @ffi.Array.multi([2])
  external ffi.Array<Matrix> projection;

  @ffi.Array.multi([2])
  external ffi.Array<Matrix> viewOffset;

  @ffi.Array.multi([2])
  external ffi.Array<ffi.Float> leftLensCenter;

  @ffi.Array.multi([2])
  external ffi.Array<ffi.Float> rightLensCenter;

  @ffi.Array.multi([2])
  external ffi.Array<ffi.Float> leftScreenCenter;

  @ffi.Array.multi([2])
  external ffi.Array<ffi.Float> rightScreenCenter;

  @ffi.Array.multi([2])
  external ffi.Array<ffi.Float> scale;

  @ffi.Array.multi([2])
  external ffi.Array<ffi.Float> scaleIn;
}

final class FilePathList extends ffi.Struct {
  @ffi.UnsignedInt()
  external int capacity;

  @ffi.UnsignedInt()
  external int count;

  external ffi.Pointer<ffi.Pointer<ffi.Char>> paths;
}

final class AutomationEvent extends ffi.Struct {
  @ffi.UnsignedInt()
  external int frame;

  @ffi.UnsignedInt()
  external int type;

  @ffi.Array.multi([4])
  external ffi.Array<ffi.Int> params;
}

final class AutomationEventList extends ffi.Struct {
  @ffi.UnsignedInt()
  external int capacity;

  @ffi.UnsignedInt()
  external int count;

  external ffi.Pointer<AutomationEvent> events;
}

enum ConfigFlags {
  FLAG_VSYNC_HINT(64),
  FLAG_FULLSCREEN_MODE(2),
  FLAG_WINDOW_RESIZABLE(4),
  FLAG_WINDOW_UNDECORATED(8),
  FLAG_WINDOW_HIDDEN(128),
  FLAG_WINDOW_MINIMIZED(512),
  FLAG_WINDOW_MAXIMIZED(1024),
  FLAG_WINDOW_UNFOCUSED(2048),
  FLAG_WINDOW_TOPMOST(4096),
  FLAG_WINDOW_ALWAYS_RUN(256),
  FLAG_WINDOW_TRANSPARENT(16),
  FLAG_WINDOW_HIGHDPI(8192),
  FLAG_WINDOW_MOUSE_PASSTHROUGH(16384),
  FLAG_BORDERLESS_WINDOWED_MODE(32768),
  FLAG_MSAA_4X_HINT(32),
  FLAG_INTERLACED_HINT(65536);

  final int value;
  const ConfigFlags(this.value);

  static ConfigFlags fromValue(int value) => switch (value) {
    64 => FLAG_VSYNC_HINT,
    2 => FLAG_FULLSCREEN_MODE,
    4 => FLAG_WINDOW_RESIZABLE,
    8 => FLAG_WINDOW_UNDECORATED,
    128 => FLAG_WINDOW_HIDDEN,
    512 => FLAG_WINDOW_MINIMIZED,
    1024 => FLAG_WINDOW_MAXIMIZED,
    2048 => FLAG_WINDOW_UNFOCUSED,
    4096 => FLAG_WINDOW_TOPMOST,
    256 => FLAG_WINDOW_ALWAYS_RUN,
    16 => FLAG_WINDOW_TRANSPARENT,
    8192 => FLAG_WINDOW_HIGHDPI,
    16384 => FLAG_WINDOW_MOUSE_PASSTHROUGH,
    32768 => FLAG_BORDERLESS_WINDOWED_MODE,
    32 => FLAG_MSAA_4X_HINT,
    65536 => FLAG_INTERLACED_HINT,
    _ => throw ArgumentError('Unknown value for ConfigFlags: $value'),
  };
}

enum TraceLogLevel {
  LOG_ALL(0),
  LOG_TRACE(1),
  LOG_DEBUG(2),
  LOG_INFO(3),
  LOG_WARNING(4),
  LOG_ERROR(5),
  LOG_FATAL(6),
  LOG_NONE(7);

  final int value;
  const TraceLogLevel(this.value);

  static TraceLogLevel fromValue(int value) => switch (value) {
    0 => LOG_ALL,
    1 => LOG_TRACE,
    2 => LOG_DEBUG,
    3 => LOG_INFO,
    4 => LOG_WARNING,
    5 => LOG_ERROR,
    6 => LOG_FATAL,
    7 => LOG_NONE,
    _ => throw ArgumentError('Unknown value for TraceLogLevel: $value'),
  };
}

enum KeyboardKey {
  KEY_NULL(0),
  KEY_APOSTROPHE(39),
  KEY_COMMA(44),
  KEY_MINUS(45),
  KEY_PERIOD(46),
  KEY_SLASH(47),
  KEY_ZERO(48),
  KEY_ONE(49),
  KEY_TWO(50),
  KEY_THREE(51),
  KEY_FOUR(52),
  KEY_FIVE(53),
  KEY_SIX(54),
  KEY_SEVEN(55),
  KEY_EIGHT(56),
  KEY_NINE(57),
  KEY_SEMICOLON(59),
  KEY_EQUAL(61),
  KEY_A(65),
  KEY_B(66),
  KEY_C(67),
  KEY_D(68),
  KEY_E(69),
  KEY_F(70),
  KEY_G(71),
  KEY_H(72),
  KEY_I(73),
  KEY_J(74),
  KEY_K(75),
  KEY_L(76),
  KEY_M(77),
  KEY_N(78),
  KEY_O(79),
  KEY_P(80),
  KEY_Q(81),
  KEY_R(82),
  KEY_S(83),
  KEY_T(84),
  KEY_U(85),
  KEY_V(86),
  KEY_W(87),
  KEY_X(88),
  KEY_Y(89),
  KEY_Z(90),
  KEY_LEFT_BRACKET(91),
  KEY_BACKSLASH(92),
  KEY_RIGHT_BRACKET(93),
  KEY_GRAVE(96),
  KEY_SPACE(32),
  KEY_ESCAPE(256),
  KEY_ENTER(257),
  KEY_TAB(258),
  KEY_BACKSPACE(259),
  KEY_INSERT(260),
  KEY_DELETE(261),
  KEY_RIGHT(262),
  KEY_LEFT(263),
  KEY_DOWN(264),
  KEY_UP(265),
  KEY_PAGE_UP(266),
  KEY_PAGE_DOWN(267),
  KEY_HOME(268),
  KEY_END(269),
  KEY_CAPS_LOCK(280),
  KEY_SCROLL_LOCK(281),
  KEY_NUM_LOCK(282),
  KEY_PRINT_SCREEN(283),
  KEY_PAUSE(284),
  KEY_F1(290),
  KEY_F2(291),
  KEY_F3(292),
  KEY_F4(293),
  KEY_F5(294),
  KEY_F6(295),
  KEY_F7(296),
  KEY_F8(297),
  KEY_F9(298),
  KEY_F10(299),
  KEY_F11(300),
  KEY_F12(301),
  KEY_LEFT_SHIFT(340),
  KEY_LEFT_CONTROL(341),
  KEY_LEFT_ALT(342),
  KEY_LEFT_SUPER(343),
  KEY_RIGHT_SHIFT(344),
  KEY_RIGHT_CONTROL(345),
  KEY_RIGHT_ALT(346),
  KEY_RIGHT_SUPER(347),
  KEY_KB_MENU(348),
  KEY_KP_0(320),
  KEY_KP_1(321),
  KEY_KP_2(322),
  KEY_KP_3(323),
  KEY_KP_4(324),
  KEY_KP_5(325),
  KEY_KP_6(326),
  KEY_KP_7(327),
  KEY_KP_8(328),
  KEY_KP_9(329),
  KEY_KP_DECIMAL(330),
  KEY_KP_DIVIDE(331),
  KEY_KP_MULTIPLY(332),
  KEY_KP_SUBTRACT(333),
  KEY_KP_ADD(334),
  KEY_KP_ENTER(335),
  KEY_KP_EQUAL(336),
  KEY_BACK(4),
  KEY_MENU(5),
  KEY_VOLUME_UP(24),
  KEY_VOLUME_DOWN(25);

  final int value;
  const KeyboardKey(this.value);

  static KeyboardKey fromValue(int value) => switch (value) {
    0 => KEY_NULL,
    39 => KEY_APOSTROPHE,
    44 => KEY_COMMA,
    45 => KEY_MINUS,
    46 => KEY_PERIOD,
    47 => KEY_SLASH,
    48 => KEY_ZERO,
    49 => KEY_ONE,
    50 => KEY_TWO,
    51 => KEY_THREE,
    52 => KEY_FOUR,
    53 => KEY_FIVE,
    54 => KEY_SIX,
    55 => KEY_SEVEN,
    56 => KEY_EIGHT,
    57 => KEY_NINE,
    59 => KEY_SEMICOLON,
    61 => KEY_EQUAL,
    65 => KEY_A,
    66 => KEY_B,
    67 => KEY_C,
    68 => KEY_D,
    69 => KEY_E,
    70 => KEY_F,
    71 => KEY_G,
    72 => KEY_H,
    73 => KEY_I,
    74 => KEY_J,
    75 => KEY_K,
    76 => KEY_L,
    77 => KEY_M,
    78 => KEY_N,
    79 => KEY_O,
    80 => KEY_P,
    81 => KEY_Q,
    82 => KEY_R,
    83 => KEY_S,
    84 => KEY_T,
    85 => KEY_U,
    86 => KEY_V,
    87 => KEY_W,
    88 => KEY_X,
    89 => KEY_Y,
    90 => KEY_Z,
    91 => KEY_LEFT_BRACKET,
    92 => KEY_BACKSLASH,
    93 => KEY_RIGHT_BRACKET,
    96 => KEY_GRAVE,
    32 => KEY_SPACE,
    256 => KEY_ESCAPE,
    257 => KEY_ENTER,
    258 => KEY_TAB,
    259 => KEY_BACKSPACE,
    260 => KEY_INSERT,
    261 => KEY_DELETE,
    262 => KEY_RIGHT,
    263 => KEY_LEFT,
    264 => KEY_DOWN,
    265 => KEY_UP,
    266 => KEY_PAGE_UP,
    267 => KEY_PAGE_DOWN,
    268 => KEY_HOME,
    269 => KEY_END,
    280 => KEY_CAPS_LOCK,
    281 => KEY_SCROLL_LOCK,
    282 => KEY_NUM_LOCK,
    283 => KEY_PRINT_SCREEN,
    284 => KEY_PAUSE,
    290 => KEY_F1,
    291 => KEY_F2,
    292 => KEY_F3,
    293 => KEY_F4,
    294 => KEY_F5,
    295 => KEY_F6,
    296 => KEY_F7,
    297 => KEY_F8,
    298 => KEY_F9,
    299 => KEY_F10,
    300 => KEY_F11,
    301 => KEY_F12,
    340 => KEY_LEFT_SHIFT,
    341 => KEY_LEFT_CONTROL,
    342 => KEY_LEFT_ALT,
    343 => KEY_LEFT_SUPER,
    344 => KEY_RIGHT_SHIFT,
    345 => KEY_RIGHT_CONTROL,
    346 => KEY_RIGHT_ALT,
    347 => KEY_RIGHT_SUPER,
    348 => KEY_KB_MENU,
    320 => KEY_KP_0,
    321 => KEY_KP_1,
    322 => KEY_KP_2,
    323 => KEY_KP_3,
    324 => KEY_KP_4,
    325 => KEY_KP_5,
    326 => KEY_KP_6,
    327 => KEY_KP_7,
    328 => KEY_KP_8,
    329 => KEY_KP_9,
    330 => KEY_KP_DECIMAL,
    331 => KEY_KP_DIVIDE,
    332 => KEY_KP_MULTIPLY,
    333 => KEY_KP_SUBTRACT,
    334 => KEY_KP_ADD,
    335 => KEY_KP_ENTER,
    336 => KEY_KP_EQUAL,
    4 => KEY_BACK,
    5 => KEY_MENU,
    24 => KEY_VOLUME_UP,
    25 => KEY_VOLUME_DOWN,
    _ => throw ArgumentError('Unknown value for KeyboardKey: $value'),
  };
}

enum MouseButton {
  MOUSE_BUTTON_LEFT(0),
  MOUSE_BUTTON_RIGHT(1),
  MOUSE_BUTTON_MIDDLE(2),
  MOUSE_BUTTON_SIDE(3),
  MOUSE_BUTTON_EXTRA(4),
  MOUSE_BUTTON_FORWARD(5),
  MOUSE_BUTTON_BACK(6);

  final int value;
  const MouseButton(this.value);

  static MouseButton fromValue(int value) => switch (value) {
    0 => MOUSE_BUTTON_LEFT,
    1 => MOUSE_BUTTON_RIGHT,
    2 => MOUSE_BUTTON_MIDDLE,
    3 => MOUSE_BUTTON_SIDE,
    4 => MOUSE_BUTTON_EXTRA,
    5 => MOUSE_BUTTON_FORWARD,
    6 => MOUSE_BUTTON_BACK,
    _ => throw ArgumentError('Unknown value for MouseButton: $value'),
  };
}

enum MouseCursor {
  MOUSE_CURSOR_DEFAULT(0),
  MOUSE_CURSOR_ARROW(1),
  MOUSE_CURSOR_IBEAM(2),
  MOUSE_CURSOR_CROSSHAIR(3),
  MOUSE_CURSOR_POINTING_HAND(4),
  MOUSE_CURSOR_RESIZE_EW(5),
  MOUSE_CURSOR_RESIZE_NS(6),
  MOUSE_CURSOR_RESIZE_NWSE(7),
  MOUSE_CURSOR_RESIZE_NESW(8),
  MOUSE_CURSOR_RESIZE_ALL(9),
  MOUSE_CURSOR_NOT_ALLOWED(10);

  final int value;
  const MouseCursor(this.value);

  static MouseCursor fromValue(int value) => switch (value) {
    0 => MOUSE_CURSOR_DEFAULT,
    1 => MOUSE_CURSOR_ARROW,
    2 => MOUSE_CURSOR_IBEAM,
    3 => MOUSE_CURSOR_CROSSHAIR,
    4 => MOUSE_CURSOR_POINTING_HAND,
    5 => MOUSE_CURSOR_RESIZE_EW,
    6 => MOUSE_CURSOR_RESIZE_NS,
    7 => MOUSE_CURSOR_RESIZE_NWSE,
    8 => MOUSE_CURSOR_RESIZE_NESW,
    9 => MOUSE_CURSOR_RESIZE_ALL,
    10 => MOUSE_CURSOR_NOT_ALLOWED,
    _ => throw ArgumentError('Unknown value for MouseCursor: $value'),
  };
}

enum GamepadButton {
  GAMEPAD_BUTTON_UNKNOWN(0),
  GAMEPAD_BUTTON_LEFT_FACE_UP(1),
  GAMEPAD_BUTTON_LEFT_FACE_RIGHT(2),
  GAMEPAD_BUTTON_LEFT_FACE_DOWN(3),
  GAMEPAD_BUTTON_LEFT_FACE_LEFT(4),
  GAMEPAD_BUTTON_RIGHT_FACE_UP(5),
  GAMEPAD_BUTTON_RIGHT_FACE_RIGHT(6),
  GAMEPAD_BUTTON_RIGHT_FACE_DOWN(7),
  GAMEPAD_BUTTON_RIGHT_FACE_LEFT(8),
  GAMEPAD_BUTTON_LEFT_TRIGGER_1(9),
  GAMEPAD_BUTTON_LEFT_TRIGGER_2(10),
  GAMEPAD_BUTTON_RIGHT_TRIGGER_1(11),
  GAMEPAD_BUTTON_RIGHT_TRIGGER_2(12),
  GAMEPAD_BUTTON_MIDDLE_LEFT(13),
  GAMEPAD_BUTTON_MIDDLE(14),
  GAMEPAD_BUTTON_MIDDLE_RIGHT(15),
  GAMEPAD_BUTTON_LEFT_THUMB(16),
  GAMEPAD_BUTTON_RIGHT_THUMB(17);

  final int value;
  const GamepadButton(this.value);

  static GamepadButton fromValue(int value) => switch (value) {
    0 => GAMEPAD_BUTTON_UNKNOWN,
    1 => GAMEPAD_BUTTON_LEFT_FACE_UP,
    2 => GAMEPAD_BUTTON_LEFT_FACE_RIGHT,
    3 => GAMEPAD_BUTTON_LEFT_FACE_DOWN,
    4 => GAMEPAD_BUTTON_LEFT_FACE_LEFT,
    5 => GAMEPAD_BUTTON_RIGHT_FACE_UP,
    6 => GAMEPAD_BUTTON_RIGHT_FACE_RIGHT,
    7 => GAMEPAD_BUTTON_RIGHT_FACE_DOWN,
    8 => GAMEPAD_BUTTON_RIGHT_FACE_LEFT,
    9 => GAMEPAD_BUTTON_LEFT_TRIGGER_1,
    10 => GAMEPAD_BUTTON_LEFT_TRIGGER_2,
    11 => GAMEPAD_BUTTON_RIGHT_TRIGGER_1,
    12 => GAMEPAD_BUTTON_RIGHT_TRIGGER_2,
    13 => GAMEPAD_BUTTON_MIDDLE_LEFT,
    14 => GAMEPAD_BUTTON_MIDDLE,
    15 => GAMEPAD_BUTTON_MIDDLE_RIGHT,
    16 => GAMEPAD_BUTTON_LEFT_THUMB,
    17 => GAMEPAD_BUTTON_RIGHT_THUMB,
    _ => throw ArgumentError('Unknown value for GamepadButton: $value'),
  };
}

enum GamepadAxis {
  GAMEPAD_AXIS_LEFT_X(0),
  GAMEPAD_AXIS_LEFT_Y(1),
  GAMEPAD_AXIS_RIGHT_X(2),
  GAMEPAD_AXIS_RIGHT_Y(3),
  GAMEPAD_AXIS_LEFT_TRIGGER(4),
  GAMEPAD_AXIS_RIGHT_TRIGGER(5);

  final int value;
  const GamepadAxis(this.value);

  static GamepadAxis fromValue(int value) => switch (value) {
    0 => GAMEPAD_AXIS_LEFT_X,
    1 => GAMEPAD_AXIS_LEFT_Y,
    2 => GAMEPAD_AXIS_RIGHT_X,
    3 => GAMEPAD_AXIS_RIGHT_Y,
    4 => GAMEPAD_AXIS_LEFT_TRIGGER,
    5 => GAMEPAD_AXIS_RIGHT_TRIGGER,
    _ => throw ArgumentError('Unknown value for GamepadAxis: $value'),
  };
}

enum MaterialMapIndex {
  MATERIAL_MAP_ALBEDO(0),
  MATERIAL_MAP_METALNESS(1),
  MATERIAL_MAP_NORMAL(2),
  MATERIAL_MAP_ROUGHNESS(3),
  MATERIAL_MAP_OCCLUSION(4),
  MATERIAL_MAP_EMISSION(5),
  MATERIAL_MAP_HEIGHT(6),
  MATERIAL_MAP_CUBEMAP(7),
  MATERIAL_MAP_IRRADIANCE(8),
  MATERIAL_MAP_PREFILTER(9),
  MATERIAL_MAP_BRDF(10);

  final int value;
  const MaterialMapIndex(this.value);

  static MaterialMapIndex fromValue(int value) => switch (value) {
    0 => MATERIAL_MAP_ALBEDO,
    1 => MATERIAL_MAP_METALNESS,
    2 => MATERIAL_MAP_NORMAL,
    3 => MATERIAL_MAP_ROUGHNESS,
    4 => MATERIAL_MAP_OCCLUSION,
    5 => MATERIAL_MAP_EMISSION,
    6 => MATERIAL_MAP_HEIGHT,
    7 => MATERIAL_MAP_CUBEMAP,
    8 => MATERIAL_MAP_IRRADIANCE,
    9 => MATERIAL_MAP_PREFILTER,
    10 => MATERIAL_MAP_BRDF,
    _ => throw ArgumentError('Unknown value for MaterialMapIndex: $value'),
  };
}

enum ShaderLocationIndex {
  SHADER_LOC_VERTEX_POSITION(0),
  SHADER_LOC_VERTEX_TEXCOORD01(1),
  SHADER_LOC_VERTEX_TEXCOORD02(2),
  SHADER_LOC_VERTEX_NORMAL(3),
  SHADER_LOC_VERTEX_TANGENT(4),
  SHADER_LOC_VERTEX_COLOR(5),
  SHADER_LOC_MATRIX_MVP(6),
  SHADER_LOC_MATRIX_VIEW(7),
  SHADER_LOC_MATRIX_PROJECTION(8),
  SHADER_LOC_MATRIX_MODEL(9),
  SHADER_LOC_MATRIX_NORMAL(10),
  SHADER_LOC_VECTOR_VIEW(11),
  SHADER_LOC_COLOR_DIFFUSE(12),
  SHADER_LOC_COLOR_SPECULAR(13),
  SHADER_LOC_COLOR_AMBIENT(14),
  SHADER_LOC_MAP_ALBEDO(15),
  SHADER_LOC_MAP_METALNESS(16),
  SHADER_LOC_MAP_NORMAL(17),
  SHADER_LOC_MAP_ROUGHNESS(18),
  SHADER_LOC_MAP_OCCLUSION(19),
  SHADER_LOC_MAP_EMISSION(20),
  SHADER_LOC_MAP_HEIGHT(21),
  SHADER_LOC_MAP_CUBEMAP(22),
  SHADER_LOC_MAP_IRRADIANCE(23),
  SHADER_LOC_MAP_PREFILTER(24),
  SHADER_LOC_MAP_BRDF(25),
  SHADER_LOC_VERTEX_BONEIDS(26),
  SHADER_LOC_VERTEX_BONEWEIGHTS(27),
  SHADER_LOC_BONE_MATRICES(28),
  SHADER_LOC_VERTEX_INSTANCE_TX(29);

  final int value;
  const ShaderLocationIndex(this.value);

  static ShaderLocationIndex fromValue(int value) => switch (value) {
    0 => SHADER_LOC_VERTEX_POSITION,
    1 => SHADER_LOC_VERTEX_TEXCOORD01,
    2 => SHADER_LOC_VERTEX_TEXCOORD02,
    3 => SHADER_LOC_VERTEX_NORMAL,
    4 => SHADER_LOC_VERTEX_TANGENT,
    5 => SHADER_LOC_VERTEX_COLOR,
    6 => SHADER_LOC_MATRIX_MVP,
    7 => SHADER_LOC_MATRIX_VIEW,
    8 => SHADER_LOC_MATRIX_PROJECTION,
    9 => SHADER_LOC_MATRIX_MODEL,
    10 => SHADER_LOC_MATRIX_NORMAL,
    11 => SHADER_LOC_VECTOR_VIEW,
    12 => SHADER_LOC_COLOR_DIFFUSE,
    13 => SHADER_LOC_COLOR_SPECULAR,
    14 => SHADER_LOC_COLOR_AMBIENT,
    15 => SHADER_LOC_MAP_ALBEDO,
    16 => SHADER_LOC_MAP_METALNESS,
    17 => SHADER_LOC_MAP_NORMAL,
    18 => SHADER_LOC_MAP_ROUGHNESS,
    19 => SHADER_LOC_MAP_OCCLUSION,
    20 => SHADER_LOC_MAP_EMISSION,
    21 => SHADER_LOC_MAP_HEIGHT,
    22 => SHADER_LOC_MAP_CUBEMAP,
    23 => SHADER_LOC_MAP_IRRADIANCE,
    24 => SHADER_LOC_MAP_PREFILTER,
    25 => SHADER_LOC_MAP_BRDF,
    26 => SHADER_LOC_VERTEX_BONEIDS,
    27 => SHADER_LOC_VERTEX_BONEWEIGHTS,
    28 => SHADER_LOC_BONE_MATRICES,
    29 => SHADER_LOC_VERTEX_INSTANCE_TX,
    _ => throw ArgumentError('Unknown value for ShaderLocationIndex: $value'),
  };
}

enum ShaderUniformDataType {
  SHADER_UNIFORM_FLOAT(0),
  SHADER_UNIFORM_VEC2(1),
  SHADER_UNIFORM_VEC3(2),
  SHADER_UNIFORM_VEC4(3),
  SHADER_UNIFORM_INT(4),
  SHADER_UNIFORM_IVEC2(5),
  SHADER_UNIFORM_IVEC3(6),
  SHADER_UNIFORM_IVEC4(7),
  SHADER_UNIFORM_UINT(8),
  SHADER_UNIFORM_UIVEC2(9),
  SHADER_UNIFORM_UIVEC3(10),
  SHADER_UNIFORM_UIVEC4(11),
  SHADER_UNIFORM_SAMPLER2D(12);

  final int value;
  const ShaderUniformDataType(this.value);

  static ShaderUniformDataType fromValue(int value) => switch (value) {
    0 => SHADER_UNIFORM_FLOAT,
    1 => SHADER_UNIFORM_VEC2,
    2 => SHADER_UNIFORM_VEC3,
    3 => SHADER_UNIFORM_VEC4,
    4 => SHADER_UNIFORM_INT,
    5 => SHADER_UNIFORM_IVEC2,
    6 => SHADER_UNIFORM_IVEC3,
    7 => SHADER_UNIFORM_IVEC4,
    8 => SHADER_UNIFORM_UINT,
    9 => SHADER_UNIFORM_UIVEC2,
    10 => SHADER_UNIFORM_UIVEC3,
    11 => SHADER_UNIFORM_UIVEC4,
    12 => SHADER_UNIFORM_SAMPLER2D,
    _ => throw ArgumentError('Unknown value for ShaderUniformDataType: $value'),
  };
}

enum ShaderAttributeDataType {
  SHADER_ATTRIB_FLOAT(0),
  SHADER_ATTRIB_VEC2(1),
  SHADER_ATTRIB_VEC3(2),
  SHADER_ATTRIB_VEC4(3);

  final int value;
  const ShaderAttributeDataType(this.value);

  static ShaderAttributeDataType fromValue(int value) => switch (value) {
    0 => SHADER_ATTRIB_FLOAT,
    1 => SHADER_ATTRIB_VEC2,
    2 => SHADER_ATTRIB_VEC3,
    3 => SHADER_ATTRIB_VEC4,
    _ => throw ArgumentError(
      'Unknown value for ShaderAttributeDataType: $value',
    ),
  };
}

enum PixelFormat {
  PIXELFORMAT_UNCOMPRESSED_GRAYSCALE(1),
  PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA(2),
  PIXELFORMAT_UNCOMPRESSED_R5G6B5(3),
  PIXELFORMAT_UNCOMPRESSED_R8G8B8(4),
  PIXELFORMAT_UNCOMPRESSED_R5G5B5A1(5),
  PIXELFORMAT_UNCOMPRESSED_R4G4B4A4(6),
  PIXELFORMAT_UNCOMPRESSED_R8G8B8A8(7),
  PIXELFORMAT_UNCOMPRESSED_R32(8),
  PIXELFORMAT_UNCOMPRESSED_R32G32B32(9),
  PIXELFORMAT_UNCOMPRESSED_R32G32B32A32(10),
  PIXELFORMAT_UNCOMPRESSED_R16(11),
  PIXELFORMAT_UNCOMPRESSED_R16G16B16(12),
  PIXELFORMAT_UNCOMPRESSED_R16G16B16A16(13),
  PIXELFORMAT_COMPRESSED_DXT1_RGB(14),
  PIXELFORMAT_COMPRESSED_DXT1_RGBA(15),
  PIXELFORMAT_COMPRESSED_DXT3_RGBA(16),
  PIXELFORMAT_COMPRESSED_DXT5_RGBA(17),
  PIXELFORMAT_COMPRESSED_ETC1_RGB(18),
  PIXELFORMAT_COMPRESSED_ETC2_RGB(19),
  PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA(20),
  PIXELFORMAT_COMPRESSED_PVRT_RGB(21),
  PIXELFORMAT_COMPRESSED_PVRT_RGBA(22),
  PIXELFORMAT_COMPRESSED_ASTC_4x4_RGBA(23),
  PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA(24);

  final int value;
  const PixelFormat(this.value);

  static PixelFormat fromValue(int value) => switch (value) {
    1 => PIXELFORMAT_UNCOMPRESSED_GRAYSCALE,
    2 => PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA,
    3 => PIXELFORMAT_UNCOMPRESSED_R5G6B5,
    4 => PIXELFORMAT_UNCOMPRESSED_R8G8B8,
    5 => PIXELFORMAT_UNCOMPRESSED_R5G5B5A1,
    6 => PIXELFORMAT_UNCOMPRESSED_R4G4B4A4,
    7 => PIXELFORMAT_UNCOMPRESSED_R8G8B8A8,
    8 => PIXELFORMAT_UNCOMPRESSED_R32,
    9 => PIXELFORMAT_UNCOMPRESSED_R32G32B32,
    10 => PIXELFORMAT_UNCOMPRESSED_R32G32B32A32,
    11 => PIXELFORMAT_UNCOMPRESSED_R16,
    12 => PIXELFORMAT_UNCOMPRESSED_R16G16B16,
    13 => PIXELFORMAT_UNCOMPRESSED_R16G16B16A16,
    14 => PIXELFORMAT_COMPRESSED_DXT1_RGB,
    15 => PIXELFORMAT_COMPRESSED_DXT1_RGBA,
    16 => PIXELFORMAT_COMPRESSED_DXT3_RGBA,
    17 => PIXELFORMAT_COMPRESSED_DXT5_RGBA,
    18 => PIXELFORMAT_COMPRESSED_ETC1_RGB,
    19 => PIXELFORMAT_COMPRESSED_ETC2_RGB,
    20 => PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA,
    21 => PIXELFORMAT_COMPRESSED_PVRT_RGB,
    22 => PIXELFORMAT_COMPRESSED_PVRT_RGBA,
    23 => PIXELFORMAT_COMPRESSED_ASTC_4x4_RGBA,
    24 => PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA,
    _ => throw ArgumentError('Unknown value for PixelFormat: $value'),
  };
}

enum TextureFilter {
  TEXTURE_FILTER_POINT(0),
  TEXTURE_FILTER_BILINEAR(1),
  TEXTURE_FILTER_TRILINEAR(2),
  TEXTURE_FILTER_ANISOTROPIC_4X(3),
  TEXTURE_FILTER_ANISOTROPIC_8X(4),
  TEXTURE_FILTER_ANISOTROPIC_16X(5);

  final int value;
  const TextureFilter(this.value);

  static TextureFilter fromValue(int value) => switch (value) {
    0 => TEXTURE_FILTER_POINT,
    1 => TEXTURE_FILTER_BILINEAR,
    2 => TEXTURE_FILTER_TRILINEAR,
    3 => TEXTURE_FILTER_ANISOTROPIC_4X,
    4 => TEXTURE_FILTER_ANISOTROPIC_8X,
    5 => TEXTURE_FILTER_ANISOTROPIC_16X,
    _ => throw ArgumentError('Unknown value for TextureFilter: $value'),
  };
}

enum TextureWrap {
  TEXTURE_WRAP_REPEAT(0),
  TEXTURE_WRAP_CLAMP(1),
  TEXTURE_WRAP_MIRROR_REPEAT(2),
  TEXTURE_WRAP_MIRROR_CLAMP(3);

  final int value;
  const TextureWrap(this.value);

  static TextureWrap fromValue(int value) => switch (value) {
    0 => TEXTURE_WRAP_REPEAT,
    1 => TEXTURE_WRAP_CLAMP,
    2 => TEXTURE_WRAP_MIRROR_REPEAT,
    3 => TEXTURE_WRAP_MIRROR_CLAMP,
    _ => throw ArgumentError('Unknown value for TextureWrap: $value'),
  };
}

enum CubemapLayout {
  CUBEMAP_LAYOUT_AUTO_DETECT(0),
  CUBEMAP_LAYOUT_LINE_VERTICAL(1),
  CUBEMAP_LAYOUT_LINE_HORIZONTAL(2),
  CUBEMAP_LAYOUT_CROSS_THREE_BY_FOUR(3),
  CUBEMAP_LAYOUT_CROSS_FOUR_BY_THREE(4);

  final int value;
  const CubemapLayout(this.value);

  static CubemapLayout fromValue(int value) => switch (value) {
    0 => CUBEMAP_LAYOUT_AUTO_DETECT,
    1 => CUBEMAP_LAYOUT_LINE_VERTICAL,
    2 => CUBEMAP_LAYOUT_LINE_HORIZONTAL,
    3 => CUBEMAP_LAYOUT_CROSS_THREE_BY_FOUR,
    4 => CUBEMAP_LAYOUT_CROSS_FOUR_BY_THREE,
    _ => throw ArgumentError('Unknown value for CubemapLayout: $value'),
  };
}

enum FontType {
  FONT_DEFAULT(0),
  FONT_BITMAP(1),
  FONT_SDF(2);

  final int value;
  const FontType(this.value);

  static FontType fromValue(int value) => switch (value) {
    0 => FONT_DEFAULT,
    1 => FONT_BITMAP,
    2 => FONT_SDF,
    _ => throw ArgumentError('Unknown value for FontType: $value'),
  };
}

enum BlendMode {
  BLEND_ALPHA(0),
  BLEND_ADDITIVE(1),
  BLEND_MULTIPLIED(2),
  BLEND_ADD_COLORS(3),
  BLEND_SUBTRACT_COLORS(4),
  BLEND_ALPHA_PREMULTIPLY(5),
  BLEND_CUSTOM(6),
  BLEND_CUSTOM_SEPARATE(7);

  final int value;
  const BlendMode(this.value);

  static BlendMode fromValue(int value) => switch (value) {
    0 => BLEND_ALPHA,
    1 => BLEND_ADDITIVE,
    2 => BLEND_MULTIPLIED,
    3 => BLEND_ADD_COLORS,
    4 => BLEND_SUBTRACT_COLORS,
    5 => BLEND_ALPHA_PREMULTIPLY,
    6 => BLEND_CUSTOM,
    7 => BLEND_CUSTOM_SEPARATE,
    _ => throw ArgumentError('Unknown value for BlendMode: $value'),
  };
}

enum Gesture {
  GESTURE_NONE(0),
  GESTURE_TAP(1),
  GESTURE_DOUBLETAP(2),
  GESTURE_HOLD(4),
  GESTURE_DRAG(8),
  GESTURE_SWIPE_RIGHT(16),
  GESTURE_SWIPE_LEFT(32),
  GESTURE_SWIPE_UP(64),
  GESTURE_SWIPE_DOWN(128),
  GESTURE_PINCH_IN(256),
  GESTURE_PINCH_OUT(512);

  final int value;
  const Gesture(this.value);

  static Gesture fromValue(int value) => switch (value) {
    0 => GESTURE_NONE,
    1 => GESTURE_TAP,
    2 => GESTURE_DOUBLETAP,
    4 => GESTURE_HOLD,
    8 => GESTURE_DRAG,
    16 => GESTURE_SWIPE_RIGHT,
    32 => GESTURE_SWIPE_LEFT,
    64 => GESTURE_SWIPE_UP,
    128 => GESTURE_SWIPE_DOWN,
    256 => GESTURE_PINCH_IN,
    512 => GESTURE_PINCH_OUT,
    _ => throw ArgumentError('Unknown value for Gesture: $value'),
  };
}

enum CameraMode {
  CAMERA_CUSTOM(0),
  CAMERA_FREE(1),
  CAMERA_ORBITAL(2),
  CAMERA_FIRST_PERSON(3),
  CAMERA_THIRD_PERSON(4);

  final int value;
  const CameraMode(this.value);

  static CameraMode fromValue(int value) => switch (value) {
    0 => CAMERA_CUSTOM,
    1 => CAMERA_FREE,
    2 => CAMERA_ORBITAL,
    3 => CAMERA_FIRST_PERSON,
    4 => CAMERA_THIRD_PERSON,
    _ => throw ArgumentError('Unknown value for CameraMode: $value'),
  };
}

enum CameraProjection {
  CAMERA_PERSPECTIVE(0),
  CAMERA_ORTHOGRAPHIC(1);

  final int value;
  const CameraProjection(this.value);

  static CameraProjection fromValue(int value) => switch (value) {
    0 => CAMERA_PERSPECTIVE,
    1 => CAMERA_ORTHOGRAPHIC,
    _ => throw ArgumentError('Unknown value for CameraProjection: $value'),
  };
}

enum NPatchLayout {
  NPATCH_NINE_PATCH(0),
  NPATCH_THREE_PATCH_VERTICAL(1),
  NPATCH_THREE_PATCH_HORIZONTAL(2);

  final int value;
  const NPatchLayout(this.value);

  static NPatchLayout fromValue(int value) => switch (value) {
    0 => NPATCH_NINE_PATCH,
    1 => NPATCH_THREE_PATCH_VERTICAL,
    2 => NPATCH_THREE_PATCH_HORIZONTAL,
    _ => throw ArgumentError('Unknown value for NPatchLayout: $value'),
  };
}

final class __va_list_tag extends ffi.Struct {
  @ffi.UnsignedInt()
  external int gp_offset;

  @ffi.UnsignedInt()
  external int fp_offset;

  external ffi.Pointer<ffi.Void> overflow_arg_area;

  external ffi.Pointer<ffi.Void> reg_save_area;
}

typedef TraceLogCallbackFunction =
    ffi.Void Function(
      ffi.Int logLevel,
      ffi.Pointer<ffi.Char> text,
      ffi.Pointer<__va_list_tag> args,
    );
typedef DartTraceLogCallbackFunction =
    void Function(
      int logLevel,
      ffi.Pointer<ffi.Char> text,
      ffi.Pointer<__va_list_tag> args,
    );
typedef TraceLogCallback =
    ffi.Pointer<ffi.NativeFunction<TraceLogCallbackFunction>>;
typedef LoadFileDataCallbackFunction =
    ffi.Pointer<ffi.UnsignedChar> Function(
      ffi.Pointer<ffi.Char> fileName,
      ffi.Pointer<ffi.Int> dataSize,
    );
typedef LoadFileDataCallback =
    ffi.Pointer<ffi.NativeFunction<LoadFileDataCallbackFunction>>;
typedef SaveFileDataCallbackFunction =
    ffi.Bool Function(
      ffi.Pointer<ffi.Char> fileName,
      ffi.Pointer<ffi.Void> data,
      ffi.Int dataSize,
    );
typedef DartSaveFileDataCallbackFunction =
    bool Function(
      ffi.Pointer<ffi.Char> fileName,
      ffi.Pointer<ffi.Void> data,
      int dataSize,
    );
typedef SaveFileDataCallback =
    ffi.Pointer<ffi.NativeFunction<SaveFileDataCallbackFunction>>;
typedef LoadFileTextCallbackFunction =
    ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char> fileName);
typedef LoadFileTextCallback =
    ffi.Pointer<ffi.NativeFunction<LoadFileTextCallbackFunction>>;
typedef SaveFileTextCallbackFunction =
    ffi.Bool Function(
      ffi.Pointer<ffi.Char> fileName,
      ffi.Pointer<ffi.Char> text,
    );
typedef DartSaveFileTextCallbackFunction =
    bool Function(ffi.Pointer<ffi.Char> fileName, ffi.Pointer<ffi.Char> text);
typedef SaveFileTextCallback =
    ffi.Pointer<ffi.NativeFunction<SaveFileTextCallbackFunction>>;
typedef AudioCallbackFunction =
    ffi.Void Function(ffi.Pointer<ffi.Void> bufferData, ffi.UnsignedInt frames);
typedef DartAudioCallbackFunction =
    void Function(ffi.Pointer<ffi.Void> bufferData, int frames);
typedef AudioCallback = ffi.Pointer<ffi.NativeFunction<AudioCallbackFunction>>;

final class rlVertexBuffer extends ffi.Struct {
  @ffi.Int()
  external int elementCount;

  external ffi.Pointer<ffi.Float> vertices;

  external ffi.Pointer<ffi.Float> texcoords;

  external ffi.Pointer<ffi.Float> normals;

  external ffi.Pointer<ffi.UnsignedChar> colors;

  external ffi.Pointer<ffi.UnsignedInt> indices;

  @ffi.UnsignedInt()
  external int vaoId;

  @ffi.Array.multi([5])
  external ffi.Array<ffi.UnsignedInt> vboId;
}

final class rlDrawCall extends ffi.Struct {
  @ffi.Int()
  external int mode;

  @ffi.Int()
  external int vertexCount;

  @ffi.Int()
  external int vertexAlignment;

  @ffi.UnsignedInt()
  external int textureId;
}

final class rlRenderBatch extends ffi.Struct {
  @ffi.Int()
  external int bufferCount;

  @ffi.Int()
  external int currentBuffer;

  external ffi.Pointer<rlVertexBuffer> vertexBuffer;

  external ffi.Pointer<rlDrawCall> draws;

  @ffi.Int()
  external int drawCounter;

  @ffi.Float()
  external double currentDepth;
}

enum rlGlVersion {
  RL_OPENGL_11_SOFTWARE(0),
  RL_OPENGL_11(1),
  RL_OPENGL_21(2),
  RL_OPENGL_33(3),
  RL_OPENGL_43(4),
  RL_OPENGL_ES_20(5),
  RL_OPENGL_ES_30(6);

  final int value;
  const rlGlVersion(this.value);

  static rlGlVersion fromValue(int value) => switch (value) {
    0 => RL_OPENGL_11_SOFTWARE,
    1 => RL_OPENGL_11,
    2 => RL_OPENGL_21,
    3 => RL_OPENGL_33,
    4 => RL_OPENGL_43,
    5 => RL_OPENGL_ES_20,
    6 => RL_OPENGL_ES_30,
    _ => throw ArgumentError('Unknown value for rlGlVersion: $value'),
  };
}

enum rlTraceLogLevel {
  RL_LOG_ALL(0),
  RL_LOG_TRACE(1),
  RL_LOG_DEBUG(2),
  RL_LOG_INFO(3),
  RL_LOG_WARNING(4),
  RL_LOG_ERROR(5),
  RL_LOG_FATAL(6),
  RL_LOG_NONE(7);

  final int value;
  const rlTraceLogLevel(this.value);

  static rlTraceLogLevel fromValue(int value) => switch (value) {
    0 => RL_LOG_ALL,
    1 => RL_LOG_TRACE,
    2 => RL_LOG_DEBUG,
    3 => RL_LOG_INFO,
    4 => RL_LOG_WARNING,
    5 => RL_LOG_ERROR,
    6 => RL_LOG_FATAL,
    7 => RL_LOG_NONE,
    _ => throw ArgumentError('Unknown value for rlTraceLogLevel: $value'),
  };
}

enum rlPixelFormat {
  RL_PIXELFORMAT_UNCOMPRESSED_GRAYSCALE(1),
  RL_PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA(2),
  RL_PIXELFORMAT_UNCOMPRESSED_R5G6B5(3),
  RL_PIXELFORMAT_UNCOMPRESSED_R8G8B8(4),
  RL_PIXELFORMAT_UNCOMPRESSED_R5G5B5A1(5),
  RL_PIXELFORMAT_UNCOMPRESSED_R4G4B4A4(6),
  RL_PIXELFORMAT_UNCOMPRESSED_R8G8B8A8(7),
  RL_PIXELFORMAT_UNCOMPRESSED_R32(8),
  RL_PIXELFORMAT_UNCOMPRESSED_R32G32B32(9),
  RL_PIXELFORMAT_UNCOMPRESSED_R32G32B32A32(10),
  RL_PIXELFORMAT_UNCOMPRESSED_R16(11),
  RL_PIXELFORMAT_UNCOMPRESSED_R16G16B16(12),
  RL_PIXELFORMAT_UNCOMPRESSED_R16G16B16A16(13),
  RL_PIXELFORMAT_COMPRESSED_DXT1_RGB(14),
  RL_PIXELFORMAT_COMPRESSED_DXT1_RGBA(15),
  RL_PIXELFORMAT_COMPRESSED_DXT3_RGBA(16),
  RL_PIXELFORMAT_COMPRESSED_DXT5_RGBA(17),
  RL_PIXELFORMAT_COMPRESSED_ETC1_RGB(18),
  RL_PIXELFORMAT_COMPRESSED_ETC2_RGB(19),
  RL_PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA(20),
  RL_PIXELFORMAT_COMPRESSED_PVRT_RGB(21),
  RL_PIXELFORMAT_COMPRESSED_PVRT_RGBA(22),
  RL_PIXELFORMAT_COMPRESSED_ASTC_4x4_RGBA(23),
  RL_PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA(24);

  final int value;
  const rlPixelFormat(this.value);

  static rlPixelFormat fromValue(int value) => switch (value) {
    1 => RL_PIXELFORMAT_UNCOMPRESSED_GRAYSCALE,
    2 => RL_PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA,
    3 => RL_PIXELFORMAT_UNCOMPRESSED_R5G6B5,
    4 => RL_PIXELFORMAT_UNCOMPRESSED_R8G8B8,
    5 => RL_PIXELFORMAT_UNCOMPRESSED_R5G5B5A1,
    6 => RL_PIXELFORMAT_UNCOMPRESSED_R4G4B4A4,
    7 => RL_PIXELFORMAT_UNCOMPRESSED_R8G8B8A8,
    8 => RL_PIXELFORMAT_UNCOMPRESSED_R32,
    9 => RL_PIXELFORMAT_UNCOMPRESSED_R32G32B32,
    10 => RL_PIXELFORMAT_UNCOMPRESSED_R32G32B32A32,
    11 => RL_PIXELFORMAT_UNCOMPRESSED_R16,
    12 => RL_PIXELFORMAT_UNCOMPRESSED_R16G16B16,
    13 => RL_PIXELFORMAT_UNCOMPRESSED_R16G16B16A16,
    14 => RL_PIXELFORMAT_COMPRESSED_DXT1_RGB,
    15 => RL_PIXELFORMAT_COMPRESSED_DXT1_RGBA,
    16 => RL_PIXELFORMAT_COMPRESSED_DXT3_RGBA,
    17 => RL_PIXELFORMAT_COMPRESSED_DXT5_RGBA,
    18 => RL_PIXELFORMAT_COMPRESSED_ETC1_RGB,
    19 => RL_PIXELFORMAT_COMPRESSED_ETC2_RGB,
    20 => RL_PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA,
    21 => RL_PIXELFORMAT_COMPRESSED_PVRT_RGB,
    22 => RL_PIXELFORMAT_COMPRESSED_PVRT_RGBA,
    23 => RL_PIXELFORMAT_COMPRESSED_ASTC_4x4_RGBA,
    24 => RL_PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA,
    _ => throw ArgumentError('Unknown value for rlPixelFormat: $value'),
  };
}

enum rlTextureFilter {
  RL_TEXTURE_FILTER_POINT(0),
  RL_TEXTURE_FILTER_BILINEAR(1),
  RL_TEXTURE_FILTER_TRILINEAR(2),
  RL_TEXTURE_FILTER_ANISOTROPIC_4X(3),
  RL_TEXTURE_FILTER_ANISOTROPIC_8X(4),
  RL_TEXTURE_FILTER_ANISOTROPIC_16X(5);

  final int value;
  const rlTextureFilter(this.value);

  static rlTextureFilter fromValue(int value) => switch (value) {
    0 => RL_TEXTURE_FILTER_POINT,
    1 => RL_TEXTURE_FILTER_BILINEAR,
    2 => RL_TEXTURE_FILTER_TRILINEAR,
    3 => RL_TEXTURE_FILTER_ANISOTROPIC_4X,
    4 => RL_TEXTURE_FILTER_ANISOTROPIC_8X,
    5 => RL_TEXTURE_FILTER_ANISOTROPIC_16X,
    _ => throw ArgumentError('Unknown value for rlTextureFilter: $value'),
  };
}

enum rlBlendMode {
  RL_BLEND_ALPHA(0),
  RL_BLEND_ADDITIVE(1),
  RL_BLEND_MULTIPLIED(2),
  RL_BLEND_ADD_COLORS(3),
  RL_BLEND_SUBTRACT_COLORS(4),
  RL_BLEND_ALPHA_PREMULTIPLY(5),
  RL_BLEND_CUSTOM(6),
  RL_BLEND_CUSTOM_SEPARATE(7);

  final int value;
  const rlBlendMode(this.value);

  static rlBlendMode fromValue(int value) => switch (value) {
    0 => RL_BLEND_ALPHA,
    1 => RL_BLEND_ADDITIVE,
    2 => RL_BLEND_MULTIPLIED,
    3 => RL_BLEND_ADD_COLORS,
    4 => RL_BLEND_SUBTRACT_COLORS,
    5 => RL_BLEND_ALPHA_PREMULTIPLY,
    6 => RL_BLEND_CUSTOM,
    7 => RL_BLEND_CUSTOM_SEPARATE,
    _ => throw ArgumentError('Unknown value for rlBlendMode: $value'),
  };
}

enum rlShaderLocationIndex {
  RL_SHADER_LOC_VERTEX_POSITION(0),
  RL_SHADER_LOC_VERTEX_TEXCOORD01(1),
  RL_SHADER_LOC_VERTEX_TEXCOORD02(2),
  RL_SHADER_LOC_VERTEX_NORMAL(3),
  RL_SHADER_LOC_VERTEX_TANGENT(4),
  RL_SHADER_LOC_VERTEX_COLOR(5),
  RL_SHADER_LOC_MATRIX_MVP(6),
  RL_SHADER_LOC_MATRIX_VIEW(7),
  RL_SHADER_LOC_MATRIX_PROJECTION(8),
  RL_SHADER_LOC_MATRIX_MODEL(9),
  RL_SHADER_LOC_MATRIX_NORMAL(10),
  RL_SHADER_LOC_VECTOR_VIEW(11),
  RL_SHADER_LOC_COLOR_DIFFUSE(12),
  RL_SHADER_LOC_COLOR_SPECULAR(13),
  RL_SHADER_LOC_COLOR_AMBIENT(14),
  RL_SHADER_LOC_MAP_ALBEDO(15),
  RL_SHADER_LOC_MAP_METALNESS(16),
  RL_SHADER_LOC_MAP_NORMAL(17),
  RL_SHADER_LOC_MAP_ROUGHNESS(18),
  RL_SHADER_LOC_MAP_OCCLUSION(19),
  RL_SHADER_LOC_MAP_EMISSION(20),
  RL_SHADER_LOC_MAP_HEIGHT(21),
  RL_SHADER_LOC_MAP_CUBEMAP(22),
  RL_SHADER_LOC_MAP_IRRADIANCE(23),
  RL_SHADER_LOC_MAP_PREFILTER(24),
  RL_SHADER_LOC_MAP_BRDF(25);

  final int value;
  const rlShaderLocationIndex(this.value);

  static rlShaderLocationIndex fromValue(int value) => switch (value) {
    0 => RL_SHADER_LOC_VERTEX_POSITION,
    1 => RL_SHADER_LOC_VERTEX_TEXCOORD01,
    2 => RL_SHADER_LOC_VERTEX_TEXCOORD02,
    3 => RL_SHADER_LOC_VERTEX_NORMAL,
    4 => RL_SHADER_LOC_VERTEX_TANGENT,
    5 => RL_SHADER_LOC_VERTEX_COLOR,
    6 => RL_SHADER_LOC_MATRIX_MVP,
    7 => RL_SHADER_LOC_MATRIX_VIEW,
    8 => RL_SHADER_LOC_MATRIX_PROJECTION,
    9 => RL_SHADER_LOC_MATRIX_MODEL,
    10 => RL_SHADER_LOC_MATRIX_NORMAL,
    11 => RL_SHADER_LOC_VECTOR_VIEW,
    12 => RL_SHADER_LOC_COLOR_DIFFUSE,
    13 => RL_SHADER_LOC_COLOR_SPECULAR,
    14 => RL_SHADER_LOC_COLOR_AMBIENT,
    15 => RL_SHADER_LOC_MAP_ALBEDO,
    16 => RL_SHADER_LOC_MAP_METALNESS,
    17 => RL_SHADER_LOC_MAP_NORMAL,
    18 => RL_SHADER_LOC_MAP_ROUGHNESS,
    19 => RL_SHADER_LOC_MAP_OCCLUSION,
    20 => RL_SHADER_LOC_MAP_EMISSION,
    21 => RL_SHADER_LOC_MAP_HEIGHT,
    22 => RL_SHADER_LOC_MAP_CUBEMAP,
    23 => RL_SHADER_LOC_MAP_IRRADIANCE,
    24 => RL_SHADER_LOC_MAP_PREFILTER,
    25 => RL_SHADER_LOC_MAP_BRDF,
    _ => throw ArgumentError('Unknown value for rlShaderLocationIndex: $value'),
  };
}

enum rlShaderUniformDataType {
  RL_SHADER_UNIFORM_FLOAT(0),
  RL_SHADER_UNIFORM_VEC2(1),
  RL_SHADER_UNIFORM_VEC3(2),
  RL_SHADER_UNIFORM_VEC4(3),
  RL_SHADER_UNIFORM_INT(4),
  RL_SHADER_UNIFORM_IVEC2(5),
  RL_SHADER_UNIFORM_IVEC3(6),
  RL_SHADER_UNIFORM_IVEC4(7),
  RL_SHADER_UNIFORM_UINT(8),
  RL_SHADER_UNIFORM_UIVEC2(9),
  RL_SHADER_UNIFORM_UIVEC3(10),
  RL_SHADER_UNIFORM_UIVEC4(11),
  RL_SHADER_UNIFORM_SAMPLER2D(12);

  final int value;
  const rlShaderUniformDataType(this.value);

  static rlShaderUniformDataType fromValue(int value) => switch (value) {
    0 => RL_SHADER_UNIFORM_FLOAT,
    1 => RL_SHADER_UNIFORM_VEC2,
    2 => RL_SHADER_UNIFORM_VEC3,
    3 => RL_SHADER_UNIFORM_VEC4,
    4 => RL_SHADER_UNIFORM_INT,
    5 => RL_SHADER_UNIFORM_IVEC2,
    6 => RL_SHADER_UNIFORM_IVEC3,
    7 => RL_SHADER_UNIFORM_IVEC4,
    8 => RL_SHADER_UNIFORM_UINT,
    9 => RL_SHADER_UNIFORM_UIVEC2,
    10 => RL_SHADER_UNIFORM_UIVEC3,
    11 => RL_SHADER_UNIFORM_UIVEC4,
    12 => RL_SHADER_UNIFORM_SAMPLER2D,
    _ => throw ArgumentError(
      'Unknown value for rlShaderUniformDataType: $value',
    ),
  };
}

enum rlShaderAttributeDataType {
  RL_SHADER_ATTRIB_FLOAT(0),
  RL_SHADER_ATTRIB_VEC2(1),
  RL_SHADER_ATTRIB_VEC3(2),
  RL_SHADER_ATTRIB_VEC4(3);

  final int value;
  const rlShaderAttributeDataType(this.value);

  static rlShaderAttributeDataType fromValue(int value) => switch (value) {
    0 => RL_SHADER_ATTRIB_FLOAT,
    1 => RL_SHADER_ATTRIB_VEC2,
    2 => RL_SHADER_ATTRIB_VEC3,
    3 => RL_SHADER_ATTRIB_VEC4,
    _ => throw ArgumentError(
      'Unknown value for rlShaderAttributeDataType: $value',
    ),
  };
}

enum rlFramebufferAttachType {
  RL_ATTACHMENT_COLOR_CHANNEL0(0),
  RL_ATTACHMENT_COLOR_CHANNEL1(1),
  RL_ATTACHMENT_COLOR_CHANNEL2(2),
  RL_ATTACHMENT_COLOR_CHANNEL3(3),
  RL_ATTACHMENT_COLOR_CHANNEL4(4),
  RL_ATTACHMENT_COLOR_CHANNEL5(5),
  RL_ATTACHMENT_COLOR_CHANNEL6(6),
  RL_ATTACHMENT_COLOR_CHANNEL7(7),
  RL_ATTACHMENT_DEPTH(100),
  RL_ATTACHMENT_STENCIL(200);

  final int value;
  const rlFramebufferAttachType(this.value);

  static rlFramebufferAttachType fromValue(int value) => switch (value) {
    0 => RL_ATTACHMENT_COLOR_CHANNEL0,
    1 => RL_ATTACHMENT_COLOR_CHANNEL1,
    2 => RL_ATTACHMENT_COLOR_CHANNEL2,
    3 => RL_ATTACHMENT_COLOR_CHANNEL3,
    4 => RL_ATTACHMENT_COLOR_CHANNEL4,
    5 => RL_ATTACHMENT_COLOR_CHANNEL5,
    6 => RL_ATTACHMENT_COLOR_CHANNEL6,
    7 => RL_ATTACHMENT_COLOR_CHANNEL7,
    100 => RL_ATTACHMENT_DEPTH,
    200 => RL_ATTACHMENT_STENCIL,
    _ => throw ArgumentError(
      'Unknown value for rlFramebufferAttachType: $value',
    ),
  };
}

enum rlFramebufferAttachTextureType {
  RL_ATTACHMENT_CUBEMAP_POSITIVE_X(0),
  RL_ATTACHMENT_CUBEMAP_NEGATIVE_X(1),
  RL_ATTACHMENT_CUBEMAP_POSITIVE_Y(2),
  RL_ATTACHMENT_CUBEMAP_NEGATIVE_Y(3),
  RL_ATTACHMENT_CUBEMAP_POSITIVE_Z(4),
  RL_ATTACHMENT_CUBEMAP_NEGATIVE_Z(5),
  RL_ATTACHMENT_TEXTURE2D(100),
  RL_ATTACHMENT_RENDERBUFFER(200);

  final int value;
  const rlFramebufferAttachTextureType(this.value);

  static rlFramebufferAttachTextureType fromValue(int value) => switch (value) {
    0 => RL_ATTACHMENT_CUBEMAP_POSITIVE_X,
    1 => RL_ATTACHMENT_CUBEMAP_NEGATIVE_X,
    2 => RL_ATTACHMENT_CUBEMAP_POSITIVE_Y,
    3 => RL_ATTACHMENT_CUBEMAP_NEGATIVE_Y,
    4 => RL_ATTACHMENT_CUBEMAP_POSITIVE_Z,
    5 => RL_ATTACHMENT_CUBEMAP_NEGATIVE_Z,
    100 => RL_ATTACHMENT_TEXTURE2D,
    200 => RL_ATTACHMENT_RENDERBUFFER,
    _ => throw ArgumentError(
      'Unknown value for rlFramebufferAttachTextureType: $value',
    ),
  };
}

enum rlCullMode {
  RL_CULL_FACE_FRONT(0),
  RL_CULL_FACE_BACK(1);

  final int value;
  const rlCullMode(this.value);

  static rlCullMode fromValue(int value) => switch (value) {
    0 => RL_CULL_FACE_FRONT,
    1 => RL_CULL_FACE_BACK,
    _ => throw ArgumentError('Unknown value for rlCullMode: $value'),
  };
}

const int RAYLIB_VERSION_MAJOR = 5;

const int RAYLIB_VERSION_MINOR = 6;

const int RAYLIB_VERSION_PATCH = 0;

const String RAYLIB_VERSION = '5.6-dev';

const double PI = 3.1415927410125732;

const double DEG2RAD = 0.01745329238474369;

const double RAD2DEG = 57.2957763671875;

const int MOUSE_LEFT_BUTTON = 0;

const int MOUSE_RIGHT_BUTTON = 1;

const int MOUSE_MIDDLE_BUTTON = 2;

const int MATERIAL_MAP_DIFFUSE = 0;

const int MATERIAL_MAP_SPECULAR = 1;

const int SHADER_LOC_MAP_DIFFUSE = 15;

const int SHADER_LOC_MAP_SPECULAR = 16;

const String RLGL_VERSION = '5.0';

const int RL_DEFAULT_BATCH_BUFFER_ELEMENTS = 8192;

const int RL_DEFAULT_BATCH_BUFFERS = 1;

const int RL_DEFAULT_BATCH_DRAWCALLS = 256;

const int RL_DEFAULT_BATCH_MAX_TEXTURE_UNITS = 4;

const int RL_MAX_MATRIX_STACK_SIZE = 32;

const int RL_MAX_SHADER_LOCATIONS = 32;

const double RL_CULL_DISTANCE_NEAR = 0.05;

const double RL_CULL_DISTANCE_FAR = 4000.0;

const int RL_TEXTURE_WRAP_S = 10242;

const int RL_TEXTURE_WRAP_T = 10243;

const int RL_TEXTURE_MAG_FILTER = 10240;

const int RL_TEXTURE_MIN_FILTER = 10241;

const int RL_TEXTURE_FILTER_NEAREST = 9728;

const int RL_TEXTURE_FILTER_LINEAR = 9729;

const int RL_TEXTURE_FILTER_MIP_NEAREST = 9984;

const int RL_TEXTURE_FILTER_NEAREST_MIP_LINEAR = 9986;

const int RL_TEXTURE_FILTER_LINEAR_MIP_NEAREST = 9985;

const int RL_TEXTURE_FILTER_MIP_LINEAR = 9987;

const int RL_TEXTURE_FILTER_ANISOTROPIC = 12288;

const int RL_TEXTURE_MIPMAP_BIAS_RATIO = 16384;

const int RL_TEXTURE_WRAP_REPEAT = 10497;

const int RL_TEXTURE_WRAP_CLAMP = 33071;

const int RL_TEXTURE_WRAP_MIRROR_REPEAT = 33648;

const int RL_TEXTURE_WRAP_MIRROR_CLAMP = 34626;

const int RL_MODELVIEW = 5888;

const int RL_PROJECTION = 5889;

const int RL_TEXTURE = 5890;

const int RL_LINES = 1;

const int RL_TRIANGLES = 4;

const int RL_QUADS = 7;

const int RL_UNSIGNED_BYTE = 5121;

const int RL_FLOAT = 5126;

const int RL_STREAM_DRAW = 35040;

const int RL_STREAM_READ = 35041;

const int RL_STREAM_COPY = 35042;

const int RL_STATIC_DRAW = 35044;

const int RL_STATIC_READ = 35045;

const int RL_STATIC_COPY = 35046;

const int RL_DYNAMIC_DRAW = 35048;

const int RL_DYNAMIC_READ = 35049;

const int RL_DYNAMIC_COPY = 35050;

const int RL_FRAGMENT_SHADER = 35632;

const int RL_VERTEX_SHADER = 35633;

const int RL_COMPUTE_SHADER = 37305;

const int RL_ZERO = 0;

const int RL_ONE = 1;

const int RL_SRC_COLOR = 768;

const int RL_ONE_MINUS_SRC_COLOR = 769;

const int RL_SRC_ALPHA = 770;

const int RL_ONE_MINUS_SRC_ALPHA = 771;

const int RL_DST_ALPHA = 772;

const int RL_ONE_MINUS_DST_ALPHA = 773;

const int RL_DST_COLOR = 774;

const int RL_ONE_MINUS_DST_COLOR = 775;

const int RL_SRC_ALPHA_SATURATE = 776;

const int RL_CONSTANT_COLOR = 32769;

const int RL_ONE_MINUS_CONSTANT_COLOR = 32770;

const int RL_CONSTANT_ALPHA = 32771;

const int RL_ONE_MINUS_CONSTANT_ALPHA = 32772;

const int RL_FUNC_ADD = 32774;

const int RL_MIN = 32775;

const int RL_MAX = 32776;

const int RL_FUNC_SUBTRACT = 32778;

const int RL_FUNC_REVERSE_SUBTRACT = 32779;

const int RL_BLEND_EQUATION = 32777;

const int RL_BLEND_EQUATION_RGB = 32777;

const int RL_BLEND_EQUATION_ALPHA = 34877;

const int RL_BLEND_DST_RGB = 32968;

const int RL_BLEND_SRC_RGB = 32969;

const int RL_BLEND_DST_ALPHA = 32970;

const int RL_BLEND_SRC_ALPHA = 32971;

const int RL_BLEND_COLOR = 32773;

const int RL_READ_FRAMEBUFFER = 36008;

const int RL_DRAW_FRAMEBUFFER = 36009;

const int RL_DEFAULT_SHADER_ATTRIB_LOCATION_POSITION = 0;

const int RL_DEFAULT_SHADER_ATTRIB_LOCATION_TEXCOORD = 1;

const int RL_DEFAULT_SHADER_ATTRIB_LOCATION_NORMAL = 2;

const int RL_DEFAULT_SHADER_ATTRIB_LOCATION_COLOR = 3;

const int RL_DEFAULT_SHADER_ATTRIB_LOCATION_TANGENT = 4;

const int RL_DEFAULT_SHADER_ATTRIB_LOCATION_TEXCOORD2 = 5;

const int RL_DEFAULT_SHADER_ATTRIB_LOCATION_INDICES = 6;

const int RL_DEFAULT_SHADER_ATTRIB_LOCATION_INSTANCE_TX = 9;

const int RL_SHADER_LOC_MAP_DIFFUSE = 15;

const int RL_SHADER_LOC_MAP_SPECULAR = 16;
